its not *necessarily* google is it? chromium is an open source project with google started right? i think anyone who wants can contribute to the project, google employee or no...
do you even understand the concept of "profit"?

what you quoted has absolutely nothing to do with profit at all, which is what we are discussing.

that "$400 million" figure is not profit. it's not even revenue. indeed, nothing is said about how much etsy made from those transactions, and nothing is said about how much is cost the to offer the service, and thus nothing is said about how profitable it was.
the article says nothing about test environments.
which is irrelevant, because we are counting minor updates, and also because chrome does not annoy the user like firefox does.
i would understand the eee comment in relation to j++ and perhaps even j#, but it makes no sense with c#.
decapitator?
and how often at the start of the cycle?
it is the absolute standard and it is quite useful. it allows to you distinguish private methods and variables from public methods and properties just by looking at them.
i actually took a year out, and we don't have "high school" here. 
no. it isn't used in java or c# at all. but it is widely used in python and php.
how long does it take just to link?  that is all you would have to do since that is the step where the final jump addresses are assigned.
most of the major c++ compilers offer at least some support for many of the new features. gcc is one of the leaders in this respect.

this highlights an important difference between the c++0x community and the perl 6 community. while it has taken the c++0x community a long time to figure out their language, at least they're performing some experimentation and prototyping while they're doing this. by the time the standard is finalized, many c++ compilers will be most of the way to fully implementing it. it'll be usable almost immediately.

perl 6, on the other hand, didn't take such a path. that's why it's ten years after its announcement, and at least two major failed implementation attempts (pugs and rakudo) later, with it being totally unusable.
perl 5 and earlier aren't. there are many individuals, companies and other organizations using it for serious work daily. it's a critical part of their infrastructure.

perl 6 is, however. it's a complete joke. the rest of the programming community laughs at the perl 6 community daily for their repeated failures.
with webgl, you get the worst of opengl's rather shitty api combined with the worst of javascript.
you are still a fucking retard, even you poorly executed attempt to imply my reasoning about how you fail to grasp what open means isn't accurate because you think i am somehow an xboxing cockfuck teen.

continue your idiotic existence, inability to reason, and use of fallacies. reddit is a fucked-up site now anyway, it won't make any difference.

cunt.
it doesn't help at all. 
consider linux-game-data with 620 ogg files. 
newer version adds two new sound effects. and we're downloading 620 old files once again. 
it's not an easter egg, and the function is not supposed to return a random number. that's the function that determines the quantity dropped from a block when it is destroyed. for most blocks it is a set number. for dirt you get 1 block when it's destroyed, then this function would return 1. this particular code is from the snow block i think, which drops 4 snowballs when destroyed. for blocks like redstone, the drops are random. for redstone blocks, the function looks like this:
    public int a(random paramrandom) {
        return 4 + paramrandom.nextint(2);
    }
that's where this function is useful, and that's why it takes a rng as a parameter. the deobfuscated name is probably something like quantitydropped(random paramrandom).
hahahahahaha
actually, this is incorrect.  while it won't stop anybody who wants to steal a password, it's a strong enough deterrent to stop people who don't want to steal the password, but don't have the judgement to stop themselves from doing so given the opportunity.

a very large percentage of crimes and generic bad judgement are things that a person was presented with or came across easily.  the same argument (if they want to do it they'll find away around) is used on other things, like regular door locks.   while those security methods do not decrease the percentage odds of success, they significantly decrease the number of attacks (which would have been 100% successful)  

a good example of this is your household door lock, which is 100% breakable but works as a solid deterrent against all kinds of casual thief.    another would be "suicide barriers" on bridges.

adding a single (beatable, but relatively obscure) layer of security will stop casual password thieves, which will prevent at least some people getting their password stolen, but won't stop people from recovering their password if they need it.
the problem usually isn't with dbas, even those without much programming experience. such people will usually be able to explain, at least at a high level, how the database handles certain operations, and where potential performance pitfalls may be.

i've actually found it to be worst with web developers. these people think that just because they can write some html, and maybe know a little bit of javascript, that they're automatically relational database experts. of course, it turns out that they aren't. if they aren't opening up huge sql injection holes, they're writing shitty queries and creating databases without keys, constraints and indexes.
after trying to write one a few months ago i can honestly say i've developed a morbid fear of physics simulation code.
&gt; "j'ai eu une somme quand vous etez entre"... "i had had a nap when you entered". 

"je faisais un somme quand vous êtes entré"

not really. if password is stored as encrypted plaintext one can just decrypt it and use directly.

if it is stored in hashed form with salt derived from some unique machine identifier (e.g. mac address, hdd serial) then attacker will either need to use patched minecraft binary or he'll need to mess with his computer just to use this password.

in other words, steal passwords will still be possible, but it will be a real pain in the ass.
as pointed out in a comment thread below by [muteh](http://www.reddit.com/r/programming/comments/fkhhb/minecrafts_rfc_11495compliant_random_number/c1glpst), it's just an xkcd joke

[http://xkcd.com/221/](http://xkcd.com/221/)
-j4, with bfs.
just so everyone knows, this is just some indian spewing shit about developing for apple devices. this has absolutely nothing to do with cisco's software.
sorry, i beg to differ. codeigniter is a horrible framework. you have a singleton class for everything ($this). there is no concept of a module/plugin you just split up your files into the only models/controllers/views folders they give you. making forms is quite slow and it gives too much freedom to the developer. frameworks like django, symfony, rails etc actually save you time by dealing with real objects (which forms can be generated from) and modules which encourage code sharing. look up a codeigniter example for just about anything and you'll see a bunch of code in a controller. validating forms should be done in the model, image resizing should be done in the view. thin controllers are good and ci discourages this.

codeigniter also has very little real community. i've seen bugs that are years old where patches exist and still have not been resolved in an official release. i think a fairly big chunk of it moved away to kohana a few years ago to solve some of the problems i mentioned above. from what i've seen kohana has good use modules and objects. ci feels *very* procedural which is why some people probably feel comfortable coming from straight php.

i really like the django way, there is one obvious way to do it and everyone follows this. for example there is one user authentication app which nearly everyone uses and life is easy. you can just download someones newsletter app from github and it works. 
there are also some really nice features like signals which allow modules to communicate in an event driven, but loosely coupled way similar to android broadcast receivers. http://docs.djangoproject.com/en/dev/topics/signals/
i don't know if php even has function decorating.

the only good thing i can really say about codeigniter is that it's quick to learn, which isn't saying much. the source looks okay i guess, but as a framework it lacks a lot of structure, which kind of misses the point of being a framework.
is spyware (bing toolbar, suggested sites) included again?
what program are you running on windows to decompile the java files?
&gt;what an unusual practice

he feels the same way about your internet metering.
i use [jd-gui](http://java.decompiler.free.fr/?q=jdgui), it's the one in the screenshot. it works pretty well. there is another that is supposedly a bit better, but i don't remember the name.

edit: jd-gui actually works for windows, linux and mac.

edit2: to clarify, that is to decompile .class files. there is no need to decompile .java files, as .java files are source.
this is [from 2009](http://blog.chromium.org/2009/07/smaller-is-faster-and-safer-too.html). they promise "we are writing a more detailed paper on courgette and will post an update when it is ready".

has anyone seen that?
"scott's new new girlfriend"
ya i meant the .class files, there were some minecraft mods i wanted to edit.
&gt; however unlike firefox, the extension system is stable and doesn't require developers to rewrite extensions every time the browser upgrades.

firefox doesn't break extensions that often. most of the time it's just a matter of the developer not marking the extension as supporting the latest version, so firefox says it doesn't support it. which you can easily override and try to load the extension anyway.
the root problem is, in [my opinion](http://use-the-index-luke.com/sql/preface), that writing sql doesn't require understanding of any database mechanics. and that's actually good. however, it causes performance problems. hence, i am trying to provide decent explanations for the *practicing developer*.
you actually don't need the encryption process to be reversible when you're building an authentication system. 

if you have a one-way function (often called a hash), you store the result of running the user's password through the function. every time your user tries to log in, you run what they give you through the same hash function and see if the result matches what you have stored. 

it's a good idea to add a machine-specific input to the hash function (these are called salts). otherwise, someone could run a lot of passwords through your hash function on their computer ahead of time and save the results (this process is called building a rainbow table). if they get a copy of your user's hash result, they can look it up in their table and then they'll know your user's password.  

edit: this is basically what killerstorm said, but for dummies. 
this type of search could be optimized if the db stored it index in a minimal acyclic finite state transducer. they are quick and easy to build. http://stevehanov.ca/blog/?id=115
"perl is a joke language" is not a joke, but "\"perl is a joke language\" is a joke" is a joke.
this link was added to the original article:
http://www.safercode.com/blog/2009/02/24/volatile-c-keyword-myths-dispelled.html

it might clear some stuff up. i don't think anyone disputes that volatile has uses. and when working crossplatform you may indeed find a case where an optimization jacked your code.

but the original point is that these are edge cases. that may be a matter of opinion, but the article is saying that volatile is overused, and that we should be hiring guys that want to use proper multi-threading primitives first.
useless information unless the application workload is given too, no?
silly rabbit, goats are for scsi problems.
i wrote the title of http://www.reddit.com/r/gamedev/comments/fjj6n/i_heard_youre_interested_in_rigid_body_physics/ in response to your /gamedev post. :p
you should uses the mcp (minecraft coder pack):

http://mcp.ocean-labs.de/index.php/mcp_releases

this not only decompiles mc, it also deobfuscates big parts of the code and also allows you to build and execute the result.

can someone explain me what's the trick with the name itself: courgette. a courgette as nothing to do with saving bandwidth.
good to know - i haven't run across this site before when rummaging for programming help.  
it's reasonably easy in erlang :)
i agree.  the content is useful, but the tone is crude.  this document makes the authors sound like they're lacking patience or have lost said patience from all the time they've put into helping others.  
i *think* fabjan might have meant that sarcastically, but as a person with a couple of years of experience in c programming in the industry, part of me wants to agree with the literal interpretation of his statement.
i'm not saying it's perfect, but there's still a big difference between the 3gb xcode/ios sdk download mentioned by mrkite77 and something like all the mono packages in debian (to take a somewhat comparable runtime and sdk). on my system i only have a few packages bigger than 100mb (the biggest being 166mb), and half of them are from third-party sources.

but the ios sdk example isn't really that relevant, the main difference with well-designed linux distributions is that you can do rolling updates, while with windows and os x you have to install monolithic service packs and os upgrades from time to time.  i'm currently running debian sid on my main desktop, which was continually updated from an original woody installation in 2004 and has followed me through 3 new computers. there obviously were some hurdles in the process, but overall it's quite a comfortable experience for power users.

also, with a centralized package management system it would be possible to add automatic binary diffs for all applications in the future.
how has nobody thought of this before? it seems like a no-brainer if you understand the structure of compiled code.
in the taxonomy of the company i worked for a long time, a *program* contrary to a *script* needs a separate compilation and linking step and its code is shipped in binary form. i don't think this definition is worse than any other.
in which case, he is part of the problem. according the wall's cult, people don't exist on a continuum: either you're going to heaven if you believe and live your life according to everything they preach, and you're definitely going to hell if you're gay. there is no middle ground. why do they deserve the respect and benefit of the doubt they refuse to give anyone else? they don't deserve it at all! they forfeit their right to that when they claim to preach the word of god about love, and do just the opposite. 

[paul haggis](http://www.newyorker.com/reporting/2011/02/14/110214fa_fact_wright) finally had the decency to leave scientology because they refused to renounce their endorsement of proposition 8. he wrote, and i agree: "**silence is consent, tommy. i refuse to consent.**" if paul haggis was so brainwashed it took him years to figure that out, then so is larry wall. will you now defend scientology's position and right to respect?

how is larry wall's cult any less hateful than scientology? just because the ancient myths and flat out lies they use to justify treating gays as less than human are more "christian" don't mean they're less hateful. they even went to the trouble of publishing a clarification that leaves no room for doubt, so larry wall has no room to claim that he believes in his cult's dogma, but doesn't hate gays, because that would be contradictory. he constantly brings up the subject of his religion in public, so the ball's in his court to denounce his cult's hateful beliefs, or else consent to it by his silence on that matter.

so now you're pulling ridiculous apologetics out of your ass for larry wall and his cult, which is even **worse** than silence: you're making up lame excuses why you think it might be ok for him tow the anti-gay agenda. not wanting to start a family tiff is no justification, when gay kids are committing suicide because of christian bullying. as long as we're wildly speculating: maybe he doesn't want to start a family tiff, because he wants to inherit his father's money. 

you're trying to justify a christian cult's hatred and larry wall's consent of hatred, therefore **you** are part of the problem too, because your stepping up to the plate and speaking out to defend and justify hatred is **much worse** than consenting to hatred by silence. 
i'd probably buy things off itunes if did'nt have to download that shitty client.
we're now hiring c# developers. you must have 15 years c# experience and 20 years .net experience minimum.
the parallelism in erlang is very explicit, though, which means it is also limited.

in haskell, you can take it even further...
&gt; i guess real world programmers will simply refuse to use it an it will remain in closed esoteric circles on the internet.

you are already wrong. everybody who uses modern versions of popular compilers like gnu and microsoft's, already has implementations of the standard library that internally use c++0x features.
no if you actually read the article the breakthrough has to do with the assembly/disassembly.
what patents exist on such a process, and who are they owned by?
actually, the closed esoteric circles are still using c and will then use c++ (c++03) after the c++0x adoption.
&gt; a good example of this is your household door lock, which is 100% breakable but works as a solid deterrent against all kinds of casual thief. another would be "suicide barriers" on bridges.

&gt;adding a single (beatable, but relatively obscure) layer of security will stop casual password thieves

actually i'm pretty sure the deterrent here is needing to get access to the computer's filesystem. nobody's going to just pass through your %appdata% folder, be tempted to steal your lastlogin file, but decide not to because it's encrypted. if they're in your computer then they are *already committing a crime*.
no brainfuck and no intercal? this list doesn't even get the best joke languages.
throw in the [dunning kruger effect](http://en.wikipedia.org/wiki/dunning%e2%80%93kruger_effect") and [confirmation bias](http://en.wikipedia.org/wiki/confirmation_bias") and you have a big problem in it when you have slightly technical people trying to micro-manage highly technical teams and are completely unaware of how shit poor they are at it. they often think they are highly competent (dunning kruger), will go with their first idea that enters their head (order is that important?) and ignore everyone else under them and reality when things start to go wrong (confirmation bias) leading to disastrous results unless the team engages in 'passive aggressive' behaviour (doing the fucking job you are paid to do).
command-line oneliner:

ruby -e "(1..100).each {|i| puts [i,'fizz','buzz','fizzbuzz'][(i%3==0?1:0)+(i%5==0?2:0)]}"


"should array indices start at 0 or 1? my compromise of 0.5 was 
rejected without, i thought, proper consideration." -- stan 
kelly-bootle

i wonder why language designers are so rigidly latched on the idea of having monolithic single version of a language. why can't we enable new features by having "`#pragma language(2011)`" at the top of the file? or by using a ".cpp2" extension?

or, if that adds too much context, why not enable this particular feature by inheriting from a magic "`compiler.supportsmovesemantics`" class?
rofl. "cross platform must fit into bobindashadows' definition or else!!"
after 2+ years, the chrome engineers have yet to figure out how to implement print preview. print fucking preview. chrome can't do it. that's so idiotic that i've sworn to never use chrome again, so i could give a shit how it does updates.
is that similar to how if a black guy is in a store he is *already committing a crime*?
to answer your question, yes.

it is the next biggest troll software after unics.
you're totally right here, v.class is from "blocksnowblock.java" in mc server 1.2.0, the method deobfuscates to 

    public int quantitydropped(random random)
    {
        return 4;
    }

so the joke is on the poster...

you're trying to argue that silverlight isn't cross platform because it doesn't run on _every single os_. lol.

you are not pointing out any legitimate facts. the only fact that's obvious from your posts is that you blindly rage against microsoft at any opportunity.
well i'll be damned. it used to be that knuth called it finished, so they only released bug fixes such that the version number approached pi.
don't, if it's brochure ware use joomla or drupal, if it's e-commerce use magento or some other derivative.
google sometimes uses weird codenames. their internal diff system is called mondrian because early mockups looked like a piet mondrian painting.
first off, to address your hyperbolic assertion about giving away phones to everyone, because google is an advertising company (assuming you know anything at all about ad companies) giving products away is a publicity stunt. are you familiar with those?  wikipedia it.

you can have allllll the strategic partners and developers you want, but if you don’t have the end-users, you don’t have a product, ask microsoft about their windows phone.  end-users are more important than developers.  ask apple about their iphone 1.0.

users attract developers, developers do not attract users, ask google about gears and wave.
that's called "[cafeteria christianity](http://en.wikipedia.org/wiki/cafeteria_christianity)": people who claim they're christian, but pick and chose what they find convenient to believe. they are **not** true christians, according to the teachings of the church. 

it's a derogatory term used by christians, about not-so-christians. but as an atheist, i find it derogatory too, because it shows the true foul character of a cafeteria christian who willfully choses to believe the parts of the bible about hating gays and subjugating women, while rejecting the parts that inconvenience their comfortable lifestyle. 

when you get down to it, most christians are cafeteria christians, and they just hate gays and subjugate women because they find it convenient and easily excusable by their so-called faith. a true christian who followed the teachings of christ would renounce and resign any organized religion that preached hatred. 

well, larry? do you renounce and resign, or are you a bigot or a cafeteria christian? 
code goes in, update comes out.

you can't explain that.
*drpepper
i guess scala solved that problem.
**in a world where perfection is impossible, one company...**
&gt; the file can be shared among developers and played back in our special time travelling debugger to instantly find the root cause of an issue. *this also means that no bugs ever need to be reproduced!*

**broke the rules**
a lot of us remember. :)
if they've banned graph paper i think they'd quickly ban transferable graph paper once they caught on to it.

maybe a better idea would be to invent a ball-point pen or pencil that accurately draws dots or lines at 1mm (or variable) intervals.

(free idea, lol!)
well, you haven't considered people who log into friends machines, shared labs, or who have roaming profiles on school/work networks.  i've had to clean out appdata folders myself due to virus infestations, both at work and for friends.  if i had a little bit less sense i might have taken some passwords to mess with people i know as a prank.  a poorly encrypted password is still always better than a plaintext one.
&gt;if you know of some major religion that is not based upon the existence of supernatural entities then i want to hear it.

then please sit down with me. i'd like to tell you about emacs.
i agree - i like perl a lot. i am not sure how well it will hold up (in job terms) over the next 10 years though.
&gt; to (re)establish rational religion, and that interests me.

i have a much better idea: how about we just dispense with religion, telling people they're going to hell, flying planes into buildings, protecting priests who rape children, slavery, subjugation of women, hatred of gays, and all the other baggage invented and justified by religion? 
for storing a password to send to a remote server at some future point,  then yes it does need to be reversible. the version stored on minecraft.net doesn't need to be reversible, but the one on your computer does.
database partition != disk partition.
minecraft, y u no have sensible function names?
...md5ing an md5ed string does not unhash it.

md5 is also primarily worthless for password hashing, since it's so fast that [rainbow tables](http://en.wikipedia.org/wiki/rainbow_table) can be easily generated.

use something like [phpass](http://www.openwall.com/phpass/).
pretty exciting.
this is a very old argument, one of the first documented cases is in fetchmail:

http://fetchmail.berlios.de/esrs-design-notes.html

&gt; password encryption in .fetchmailrc
&gt; 
&gt; the reason there's no facility to store passwords encrypted in the .fetchmailrc file is because this doesn't actually add protection.
&gt; 
&gt; anyone who's acquired the 0600 permissions needed to read your .fetchmailrc file will be able to run fetchmail as you anyway -- and if it's your password they're after, they'd be able to rip the necessary decoder out of the fetchmail code itself to get it.
&gt; 
&gt; all .fetchmailrc encryption would do is give a false sense of security to people who don't think very hard.

err.... how?

if you aren't checking digital signatures on updates, there's no protection at all against someone tampering with the update to install malware. if you're doing auto-update, you must sign the updates, and have the update client check them.

if you're doing that, it doesn't matter if the update it 10mb or 78kb.
then there's the tool chain to consider. generating (or rather keeping) the required information is much easier in the compiler rather than in post-processing.
your theory seems to be that a person willing to retrieve the minecraft password file won't put forth the effort to type http://lmgtfy.com/?q=minecraft+password+decrypter into google.

your ideas are misguided, at best. this argument is decades old and you're on the ignorant end of it.
does this guy work at gawker?
i'm curious, is the generator the only way you talk to god?

it seems to me you take this arbitrary string of words and create connections between them that make perfect sense to you.

i'm not belittling your worldview, i had something similar when i smoked a lot of pot and became somewhat psychotic. at the time i was heavily interested in body language, unconscious communication, etc. i would "see" connections between people, their intentions and revert it all through a filter in my mind that had the assumption of "everyone is out to get me".

thankfully the condition wore away after i stopped smoking, it's still there but it's easily manageable. i feel sorry that you have to live with this day in and day out.
also, firefox obeys "show windows stacked."  and i bet if it ever *didn't* they wouldn't just let it sit for three goddamned years without ever doing anything about it.
that isn't what the lgpl says. (and the lgpl is an issue for people on some platforms, like game consoles.)
agree...  but you can use eclipse for both languages, with a similar featureset, and it's free.
lol
that is missing [bounding interval hierarchies](http://en.wikipedia.org/wiki/bounding_interval_hierarchy) in the spatial trees category or maybe it should be in the binary space partitioning category...
cool, but seems to be poor substitute of debugger: it does not allow object graph navigation. it only shows primitives, strings, and primitive object wrappers on stack.
i guess when one considers the history behind erlang, and its current uses, the explicit form of parallelism makes sense. the ability to control what, how and where a process is spawned; and been able to implement both a synchronous and asynchronous messaging behavior between processes for example. i am in the process of starting to learn haskell so can't comment much on that language wrt parallelism, other than to say that it appears they share a lot of common ground (so far it seems like a great language). 

the company i work for has a number of products written in erlang and also c/c++. i work in both environments (and i do like c/c++), but get rather frustrated with the c/c++ developers when they criticize erlang (although they've never used it) as been a "slow interpreted language running on a vm". these same developers constantly produce buggy, slow c++ code because they are constantly fighting around global locks and badly implemented threading models and issues with the various frameworks they insist on using (ace for example). where, frankly, the erlang products have always been top-notch quality, high-performers, and are always delivered on time. i guess that's the attitude one normally refers to as fud.
the list is missing [whitespace](http://en.wikipedia.org/wiki/whitespace_(programming_language\)).
i code in what the high-paying employers have been telling me to code in for the past 11 years.
is it fed the random number because it's overwriting some inherited method? just trying to understand it more. (i totally agree, though)
i think i saw it in a book. can't remember the title of the book, it was about writing modular c code.
you're right; i wasn't thinking.
there's some pretty questionable code in there. for nsstring, that logit function uses the deprecated cstring which will probably output garbage for anything but ascii, and it logs to stdout instead of the expected stderr.
some other thread was talking about this, but i'm probably wrong about this too.

i'm going to bed now. 
what you want is called a [bounding volume hierarchy](http://en.wikipedia.org/wiki/bounding_volume_hierarchy) but i don't know of any implementations that support anything other than aabb volumes.
for something that claims to be blazingly fast, it doesn't seem very responsive
why 9 and not 4?
http://en.wikipedia.org/wiki/obfuscated_code#obfuscating_software
allow me to introduce you to presto: http://lwn.net/articles/329484/ :)
oh, look, it's that old xkcd joke again.
allocating more jobs than you have cores can sometimes increase throughput, especially if one of the compiles can keep using cpu time while another is waiting on i/o. it doesn't always work out favorably but most of the time it does in my experience (i have a 6-core box and i compile with -j8)
am i missing something here? the pe file format can include a relocation table. in fact almost all compiled dlls have one because they most likely aren't going to end up in their preferred image base.

i guess people that compile .exe files just never include a relocation table. after all, the binary in a virtual address space (probably) always gets the requested image base so no relocation fix ups are necessary.
but they do. http://codeascraft.etsy.com/2010/05/20/quantum-of-deployment/
what would be the point in distributing assembly?

you may as well distribute the binaries, it'd be quicker.
op doesn't know the difference between a parameter and a method name
do you even understand how to back up a claim? once again you fail to do any research. it took me about sixty seconds to find this:

&gt; etsy is a profitable private business that is valued at about $100 million; earns between $15 and $20 million in annual revenues

http://online.wsj.com/article/sb10001424052702304370304575152133860888958.html?mod=wsj_hp_editorspicks
wtf? md5 is very easy crackeable... there are too much words with same hash. instead this use sha1(string $str); better with salt.
&gt;:-/

you mad?
i was thinking hands on the hips, pelvic thrust, and a stare right in the eye.
huh no, it's similar to how if a burglar has broken into a house he is already committing a crime.
languages such as erlang, scala, f#, and c#/vb version 5 do well with fork/join parallelism, but that's only one piece of the puzzle.  maybe that's even low hanging fruit.  there still are plenty of problems to be solved with parallel and concurrent programming.
i am a programmer for a company that uses qt in its commercial offerings. we buy support contracts for all the developers because it is an essential piece of our development. also, lgpl compliance is a pain because it means that at least our legal department would have to take a look at it. 

if a sufficiently credible amount of the people that made up trolltech when it was still an independent company would buy back qt from nokia to basically restart trolltech, we would continue to pay them without asking any questions at all.
it's actually irrelevant what profit it has, for this discussion. any form of broker doing $400 million in transactions is a serious entity and not a standard web 2.0 company.

if you heard that a 3 year old hydrogen exchange was doing $400 million in transactions you'd consider them a "real company" whether they were making any profits yet or not.
can you elaborate on that statement, and provide some supporting evidence or documentation for that assertion?  

further, what aspects of scala make it so well-suited to parallel programming?

scala in its current implementation is still bound by the limits of the jvm and supporting class libraries, which are not necessarily tailored for parallel development.
more spam from andrey karpov.
did you ask your parents if this was ok? they were instrumental in the creation of your dna.
it's funny because it's true
yeah, it also doesn't say that they do not use every other standard software development practice. just because they use one software development practice that is novel does not mean that everything else is discarded. here's what they say about their test environment at imvu, where they also use continuous deployment:

&gt; great test coverage is not enough. continuous deployment requires much more than that. continuous deployment means running all your tests, all the time. that means tests must be reliable. we’ve made a science out of debugging and fixing intermittently failing tests. when i say reliable, i don’t mean “they can fail once in a thousand test runs.” i mean “they must not fail more often than once in a million test runs.” we have around 15k test cases, and they’re run around 70 times a day. that’s a million test cases a day. even with a literally one in a million chance of an intermittent failure per test case we would still expect to see an intermittent test failure every day. it may be hard to imagine writing rock solid one-in-a-million-or-better tests that drive internet explorer to click ajax frontend buttons executing backend apache, php, memcache, mysql, java and solr. i am writing this blog post to tell you that not only is it possible, it’s just one part of my day job.

our company would buy qt licenses just for avoiding having to send every release over to our legal department to sign off on lgpl compliance. if support would be anything remotely close to what we got back in the day when we bought support licenses from the independent trolltech company, that would also be reason enough to buy a license. 
not for users who hardly, if ever, close chrome at all.
it doesn't need to send the password to the server, that's the point. it could just send the hash...
&gt; i wonder why language designers are so rigidly latched on the idea of having monolithic single version of a language. why can't we enable new features by having "#pragma language(2011)" at the top of the file? or by using a ".cpp2" extension?

c# does this - putting "using system.linq" at the top of your file allows special linq query syntax to be used. 
why does everyone check for the 15? just print "fizz" when it's a multiple of 3 and a "buzz" when it's a multiple of 5. for numbers where both are inside, fizzbuzz is print without a 3rd case. just print the line break at the end of the iteration...
they released me under the wtfpl.
ya, that's probably why. seems odd that he passes the random object into the function, it would probably more applicable to store the object statically somewhere so you can access it only when you need it, and without passing it in to the function.
we're not talking about buying licenses here, we're talking about buying qt development frameworks (formerly trolltech) itself.
ಠ_ಠ
i wished.  i though about asking just that question on reddit: 

"where do you go for debugged libraries and agorithms in c - or do you always create your own?"
well, doesn't have to be that. just imagine from the moment they do patch the exploit and the moment you get that patch.
the attributed string enumeration could also be made much faster using a 10.5+ for loop.
i've been "testing" it for about 6 months now and i think it works about as well as flash can. 
and thanks for that, i bookmarked the whole website to read the book..

i've been working at a job (as a student) for about 10 months, it's a web app with a very complicated and large oracle database. 70% of my time is spent with sql and pl/sql.. i consider myself pretty good at sql and pl/sql in general but i lack the knowledge to properly optimize, or sometimes get lost on how to write a proper query(a complicated one).

so what website/ebook is available for me to take the next step into sql and oracle ( i want to learn databases and oracle in 'n out, i want to learn how my query gets executed and how i can optimize and how to write complicated queries)

thanks mang

also just to note that i'm a computer science student with a strong programming background, and at my job, i probably write more time programming in pl/sql to develop new features on our web app which includes writing alot of queries (we are very concerned with the speed of our app)
thank you! thought i had seen this somewhere else just couldn't remember where. now i do :)
&gt; frankly, i think there should be a single field for addresses, and the normalization onus should be on those who need the address components, not those who are entering them.

i believe amazon did just that for international addresses at some point. you chose international from a dropdown and got a multiline text box. now they have a standard form, but don't require all the components (so i don't have to figure out some placeholder to write into the territory field, like i have to on some sites).
it seems more complicated that it should be. you must also remember that pipes can hold arbitrary-sized elements. what if i try to pipe_pop_multi with two consumer handles with different elem_sizes?

if it should just fail, now i have to figure out how to gracefully handle error conditions. i'd rather it "just work" or warn at compile-time if it doesn't.
when i said i didn't code in ruby anymore, i meant *that day*.  i was finished for the day. my day job is ruby evangelist for a stealth-mode yc startup.  so ya, i think i code a little ruby.

gentu is a source-based distro created from ubuntu sources. so it is a combination of gentoo and ubuntu. my main machine is a dell mini 9 hackintosh but it broke from software update. apple sux.

so you are not aware that cucumber is a tool that executes plain-text functional descriptions as automated tests? *thought you knew.* :(
this is a joke!
fred wilson is the biggest lottery winner of life. he's a border line dolt who plays with a lot of other peoples money.  i didn't read the blog post, but what does a vc have to do with a development decision? he should stick to writing about his love hate relationship with apple/microsoft/google.
that's not what i was getting at. my argument is that software engineering should be as strict as other forms of engineering *because* software powers nuclear plants, airplanes, and etc.
very nice coding style.

i also appreciate that you actually documented your code, and didn't throw a pile of c out there for people to decipher.
where do you learn these things from?  most c books will teach you about the lanuage syntax. newcommers then move to data structures and algorithms.

the c standard library does not even contain a linked list.

**where do i go to obtain debugged versions of these algorithms?**

thanks for any input you have.
care to provide a bit of context on this one?
just checked -- no, it's not like that, the compiler parses linq syntax correctly regardless, but without system.linq it can't find any extension methods for ienumerabe.
it's complicated yes, but it's known and relatively free of "bugs" having stood the test of time... or at least a human time scale. one can't say the same of most software. 
i have looked all over for the "standard" c data structures library and have come up empty handed.

would you say it's true that most c programmers create thier own data structures from scratch?
no, the language is named delphi now as well. they changed it a few years ago.
thanks for this.

are there any others you could recommend?
a random-generator in java is an object which abstracts the way random numbers are generated. look at it as a function which returns a new random number on each call. of course internally those random generators store a state which is used to calculate the next number. 

now in minecraft many random numbers are "seeded" to make sure that a certain call sequence always gives the same sequence of random numbers. 

for example in the world generator the seed is calculated from the position in the world (the 'chunk position') and a "world-seed". this way the world generator can create the exact same world from the same world-seed without the necessity to store and calculate the whole world in the beginning. 

but this only works if you are careful how to create and use those random generators and because of this most methods which deal with random values are called with a random generator as an argument.

doesn't make it anymore efficient.
the fact that you can buy something makes it "production quality" by now? at least according to my definition, this is bullshit. production quality means that something works well in practice and it's not decided by manufacturers, but by users.

also, relative comparisons like that don't hold up well in general. you know, mubarak wasn't really bad, hitler was clearly worse.
in the year 2011 it is a joke to still use perl.

seriously. perl lost to ruby and python.

r.i.p. perl.
you missed the punchline:
&gt;after years of languages such as c++, java, and ada in cs1, which hastened the exit of many a potential cs major, it's ironic that our new problem might be students succeeding too long for their own good. when they do discover that cs isn't for them, they will be stuck with the ability to write scripts and analyze data.

&gt;with all due concern for not wasting students' time, this is a problem we in cs should willingly accept.

the author is advocating *for* python.
they *do*. 

in osx, chrome is updated via chrome itself, on a timed basis. 


*and on reddit, i get fifteen downvotes for posting something completely factual. ugh.*
yeah, it seems that i'm wrong. sorry about that. i think i got the wrong idea from some poorly worded documents on linq. 
on posix systems, &lt;sys/queue.h&gt; has nice linked data structures.  'man 3 queue' for usage instructions.

https://github.com/attractivechaos/klib has a really nice hash and some other useful stuff.

the cool thing about both of these is that they (ab)use the c preprocessor so void * don't need to be passed around and dereferenced.  in effect, they are like template metaprograms in c++.  this kind of code is very difficult to write but these have been used enough that they should be safe.

i'm at best in the intermediate stage myself and trying to build up my toolset by exploring existing projects and such.  a systems book like "advanced programming in the unix environment" is probably a decent choice if you don't already have it.

http://www.oracle.com/technetwork/database/berkeleydb/tutorial-berkeleydb-ds-084870.html is an interesting tutorial on bdb.  bdb is written with a fairly oo style interface and is an otherwise useful library, so this is worth working through.
its not fed a random number, what is fed it a random number generator. if you want to get a random number, you need to call for example nextint(10) on it to get a random number from [0, 10[


i'd like to have it open new tabs (optionally at least) with the right button, so it works more like the tab mix plus (with appropriate settings) on firefox.   i use both browsers now and sometimes have to think before clicking to remember which behavior is which. 
in which case, if you have the hash, you can log in. thus the hash becomes the password.
ah, but the natural world has no use for product clycles and release dates. it's driven by pure darwinism. i would argue a perceived "cludge" in the natural world only appears so because it it not fully understood.  remember, humans are not economicly rewarded for redundancies (they increase cost) but the natural world has no such economic construct in which to confine it. under this paradigm redundancy is embraced as an advantage which is why humans have two kidneys (for example). under an economic model that would be considered waste! i mean look at the extra weight and energy needed to bear such a burden? but somehow this has been deemed evolutionarily useful dispute the "costs" associated with such an inefficiency
permalinks are available from the sidebar in standard mediawiki installations. [like this one](http://esolangs.org/w/index.php?title=joke_language_list&amp;oldid=20883).
&gt; software engineering is a subset of computer science.

are you trying to claim that software architecture, testing, and hci are part of cs? i think there are lots of cs purists that would disagree with that.
i don't see that as a problem at all. it's the reason sql was invented--so that non-programmers could "easily" access data. 
the original proposition was that monetizing qt is impossible and therefore no one would be willing to buy it. i am refuting that notion by saying how qt could continue to generate revenue by selling support licenses and therefore be eligible for a buy by someone. there might be some serious downsizing going along with that but if it means bringing back focus to a nice c++ toolkit for desktop application development it might not even be a loss for potential customers like us.
for the last time, revenue is not profit. earnings are not profit. ever hear of taxes?
i'm a dba that can't program!  i read this article and was just like, "duh".  if you think about it, of course it's going to take more time that way.  i don't think creating the best, efficient queries requires any knowledge outside of a thorough understanding of sql and how your database is structured. i have no idea how to program squat... i mean outside of a few lines of html, which i wouldn't brag about.  never a cs class in my life either... just read stuff and talked to a programmer friend when i was learning.  all it takes is a logical mind to get it right.  i can very well understand what the software does because i use it. 
if you want to pass a dependency to a constructor then just do it.  it's an obvious way to write unit-testable code.  has nothing to do with the bloated di frameworks i was complaining about.
my theory is based on the assumption that there is already a person there, and that he's not willing to put the effort forth,  it takes it into account as part of the premise, can't you even read?  do you need me to spell it out for you with an analogy and a little story?

how about there's a guy who has broken into my garage.  my car is a model that can be very easily hotwired and it's unlocked.  there's nothing stopping him from stealing it, but the keys aren't there.  if he doesn't know the model, or doesn't want to read the service manual (even if it's right on the desk) he won't steal it.  having no keys in the car is not as good as locking the doors, but it is better than having keys in the car.  that's the entire premise of my "theory".  the barrier of poor encryption is much lower, but it's still there and fits the scenario.

if you're going to argue, please at least argue against what i'm saying rather than arguing against an imaginary person saying something wrong.  i know it might require you to do some critical thinking, but you'll get more out of it, i promise.

as for the research, google "crimes of opportunity" and you can find the proof that what i'm saying (not what your strawman is saying) is correct.  hell, [let me google that for you](http://lmgtfy.com/?q=crime+of+opportunity)
'is' in this context indicates equivalence so the 'just' part is implied, so the statement 'not exactly' in response to 'software engineering is a subset of computer science' appears to be valid.
from zero to launch in under an hour, [source available](http://github.com/shadowhand/colormyip).
vous etez correct, bien sur. merci.
except fedora
i'm fairly sure when something is decompiled, it doesn't retain the original function names....
meaningless decompiler outputs.
ah, i should have said - i'm from the united states.
i know a lot of devs that don't have any sort of db training.  their gateway into using them is to learn sql.  for a lot of these people, it functions as a black box where you just write a query to grab data out of it.  it isn't until they get bitten by doing something along the lines of "where city_name like '%ville'" that they start to see it's easy to screw things up in the system without meaning to.  

the article is short, simple, and pretty obvious to a lot out there, there's definitely an audience that can learn from it.  thanks for sharing.
yes, that's true if the hash is generated and stored on the client-side.

i would liken a proper implementation to an http session cookie, a "password" created from a random string of data that could be invalidated if necessary.
i don't understand why anyone would use gtk+ in 2011.
&gt; it's also known to be the only widespread use obfuscated language
let me re-quote:

&gt; "etsy is a profitable private business"
almost the same bs, except upside down.
there is also the other side of cluelessness. every few months we have an all-hands meeting. there are so many people that we have to move a few goodies out onto the manufacturing floor (screen, projector, portable pa system, laptop with network connection). for the first time ever, we've been told to make sure that they can play a video. being super-secret, we don't get to see the video until the ceo plug a usb stick into the presentation laptop during the meeting. nobody can tell us what format the video will be. nobody can tell us if the video was shot in a way that can survive presentation on a 12-foot screen from a portable 'powerpoint-style' projector. nobody can tell us if the audio was recorded at levels that allow us to use a set of portable computer speakers to get sound out to 150 people spread over an area of 400 sq ft on a 10,000 sq ft shop floor. nobody is giving us any budget for audio equipment (mixers, amps, speakers, etc.) that give us some hope of coping with the sound. we have 3 working days to sort it out, only 2 of which have both it people available. and we're in the middle of a voip deployment and the development a brand-new application for distribution to a set of employees that, as yet, do not have user accounts on our system or even access to computers.
the pull request is brilliantly funny - https://github.com/msporny/dna/pull/1
~1 minute to link, on a fast machine with using 100% of one of your cpus - which would be very disruptive on a user's machine!
it happens more often than you'd think, for many different reasons.
java does retain the original names in order to make reflection and stacktraces usable, *unless* you run the code through an obfuscator (like notch does).
any physical security is mere obfuscation. this is good because it prevents someone getting to your machine and just running scans, like the intext search functions, to get your password. it's a happy medium between no "security" and a complex and expensive obfuscation that wastes dev time and would only take hackers a week/month to de-obfuscate, should they wish.
it's an inside joke language according to esolangs.org
no patents. it seems colombians don't like to file them.
it's actually not; this is just a coincidence. see the best comments for an explanation.
store the user's password on disk as a [bcrypt](http://codahale.com/how-to-safely-store-a-password/) hash, send hash to server on game login. steal a user's ~~password~~ hash and you can play as them, but you can't login to the website as them.
&gt; unfortunately it doesn't always make me right

that does not make sense. either you are right, or you are wrong (f.e. due to lack of information). whether that is recognized by other is a different topic.
recently i've decided to take on learning sql (through these [youtube](http://sqlzerotopro.com/) videos)..it's been very easy so far, but as a business administration major, will knowing this help me get anywhere in a corporate setting?
http://www.reddit.com/r/programming/comments/fkhhb/minecrafts_rfc_11495compliant_random_number/c1gm8zi

judging from the name of the application, i think it is a tool by the farbrausch collective who are best known for their 64k intros (at least to me who doesn't follow the demoscene very closely). i assume that storing π as an integer saves them a few bytes. to render the cylinder in the picture, 3 could very well be a good enough approximation to compute the number of segments you need to close the circle.
i should have probably known this seeing as we were taught with java in first year uni. nice to know i promptly forgot everything i learnt. 
*written* and *used* parts are non-remarkable. *maintained* is where the joke becomes obvious.
almost 1000 lines of c!? you can do it in 3 lines, thread-safe, "lock-free", in the kernel and in batch if you want. 

pipe(p);
write(p[1], &amp;data, sizeof &amp;(data));
read(p[0], &amp;data, sizeof &amp;(data));

from what i remember of iwyu's slides at an llvm conference, it will let you know when a forward declaration will suffice.
is anyone else disturbed that the gremlin changes colors from the first frame to the third frame?
pretty much :)

what cracks me up is that i've applied for some jobs that were ideal for me, that i felt at the end of the day i did not get for this very reason in combination with bullshitters.

i have a friend who states he has "deep technical skills" that actually has very little in the way of technical skills.  great bullshitter and absolute liar though, so no problem getting a job for him.

sometimes i think my candid nature works against me too much and that i'd be better off just lying the next time i need to find a job.  it just irritates me to think that i'd need to do something like that.

thankfully i like the current job i have so its not a problem i'll have to deal with any time soon :)
http://developer.nvidia.com/object/nsight.html
not in the strictest sense. man you are hella stubborn today. just admit you're wrong and don't argue all the time, young dude. stop harshing the sunday mellow here. it's *wake and bake, thought you knew.*
if you can log into the server without typing in a password, then the information required to get in is on your local machine and thus can be stolen. this is true regardless of what mathematical methods are used or if it's a random string of data.

it's not a bad idea to shroud the password when storing it locally. it's nowhere near completely secure but it protects against some casual attacks/information leaks.
i find the command prompt horrible to work with, and powershell is still inferior to a good ol' linux terminal. i use windows and linux, but i use windows for gaming and photoshop more than anything else. windows is only really better when coding in c#, and that's because of visual studio.

**edit** your post had nothing to do with it, i was just addressing the downvotes.
every article gets downvoted. this is not something it is worth worrying about. this one actually has a far higher ratio of upvotes to downvotes than the average story.
how come so many sites are using that horrible fucking layout now?
but i like imgur
are you lanning on writing some snp search software?  with the creative commons license, it should be easy to scrape snpedia and create a searchable snapshot...
&gt; a courgette as nothing to do with saving bandwidth.

the courgette is a squash, squash is a synonym for compress.
haskell pwns ocaml.
right, and now that new c++ features will break their previously correct code, they'll have no choice but to learn it! it's brilliant
cool! is the source available online?
if apple considers it's h.264 encoder to be production quality, then they must consider anything better to also be production quality, correct? apple is one of the main opponents of webm and proponents of h.264.

i did not say that you must consider it to be production quality. i apologize for using the passive voice.

that's my contemplative emoticon.  if i'm mad, it's usually "grrr"
sorry no, not specific to c.
your sql skills, should they matter, will be the *only* skills that matter to your career.
well... i think most chrome updates are under a few megabytes, which under most mobile data plans should be no problem whatsoever.

but sure, granted. (but how many people are on a mobile data plan all the time?)

(btw, i don't like the fact that it runs without user consent, i'm just trying to clear up misconceptions.)
&gt; most of the major c++ compilers offer at least some support for many of the new features. gcc is one of the leaders in this respect.

but as the article points out, you can't just recompile your code as c++0x and be confident it will work. all code may have to react. the problem is confounded by the fact that c++ libraries are often provided as templates. you can only use c++0x if your code has reacted and all the headers you want to use have reacted as well. that's a tall order.
of course apple eats their own dogfood, but i've never heard of anyone else in the industry using apple's encoder.
you don't have to look that far.  the list is missing intercal for goodness sake.  that's like making a list of major chocolate companies and forgetting hershey's.
after gaining lots of experience using opencl, mpi, and openmp; i have come to one conclusion. it's all far too much effort! nobody wants to be worrying about parallelising code (which can be horrifically complicated to achieve and optimise). i think the only real logical step that will make parallel programming a universal practice is the development of seriously-smart compilers that can parallelise everything automatically.
that's essentially what the "=default" approach is: a way to request default (but not implicit) behavior. that or boldly breaking code would have both been better alternatives than the milquetoast compromise, which breaks correct code for little gain.
it combines all the great aspects of bash and sed with awk's syntax.

it is totally a troll language, and it was obviously written by someone who all they ever did was write lots and lots of shell scripts previously. anyone who likes working in those 3 tools, and writing scripts in them longer than a few lines needs their heads examined.

there are a lot of languages developed in ivory towers, that contain a lot of awesome lofty contents, and really stretch how you think about programming, but are unsuitable for large scale coding.

and there are languages developed by those 'in the trenches' that grew 'organically', and include whatever the developer that developed them thought was important to him. but they have no overreaching design goals, lack beauty, and have 'features' that make it difficult to use them to design large, comprehensible, easy to read systems. learning them also won't teach you anything new. perl and php fall into this class.
http://validator.w3.org/check?uri=http%3a%2f%2fwww.subway.com%2fsubwayroot%2findex.aspx&amp;charset=%28detect+automatically%29&amp;doctype=inline&amp;group=0
i can't open source my dna. some of the genes are patented.
my hat's off to you for managing to up the pedantry level of this thread. :)
i am not sure if i posted it in the right category. please correct me if i'm wrong! thanks!
i work at a company that handles insurance information and we mostly just use numeric keys to access data, so i never really had to deal with strings until recently. credit info is apparently ordered by insurance companies from a separate third party and the companies just insert the raw data into the database. this results in ridiculous fields with 500 characters separated only by spaces here and there to denote where one code ends and another begins. so i had to write a ridiculous query just to check and see if their credit was good or bad, it looked something like this:

    select 1
    from creditreturn
    where sectiontype like '%ri51%'
    and status like '%u%'

i sat for about 30 minutes just looking at this query and thinking, "fuck." by the way, the raw return looks something like this:

    00000000034231000 99 2812300johnmdoe00382 000000000000010000

...except 20 times longer and *all* in the same field. not sure who thought it'd be a good idea to arrange the data this way, but we don't (can't?) have any contact with the third party that imports the data, so we're stuck with it.
oh yes, this looks deprecated.
maybe contacting the author for fixing this...

does anyone know about a more up-2-date list similar to borkware quickies?
so now you've moved from storing a password which could be stolen and used to log in in to someone elses account, to storing a hash which could be stolen and used to log in to someone elses account. what have you gained?
i hope you take this the right way, but you need a proper writer for your copy. the translation from russian is painfully obvious. same goes for the ppt describing your product.
many defense systems are written in ada. 

forth is used in a lot of embedded systems. 

there is more out there than just desktops.
what is it that you don't understand about locuester's post? he didn't say anything bad about vs. on the contrary, he told hammered that vs also has a feature that eclipse has.
offline mode. you are proposing a stricter drm scheme, and extra workloads on notch's servers.
they're too busy writing missle guidance and control systems.
last idiot question to help my understanding. if this method returns the number of snowballs returned from one block of snow, why not just store the number as a constant or a private variable somewhere? just to keep it uniform with other drop values like the redstone block example above?
definitely. it will all come down to what kind of job you apply to, but having that sql knowledge backing you up in your resumé can certainly add you some very valuable points when looking for a job. data and information keeps increasing as an incredibly valuable asset and so does data management. good luck!
style is one thing, content is another. in this case there are almost 1000 lines of c code which can be replaced with 3 lines if the author had done; 'man 2 pipe'. the best style is the code never written.
there is no rfc 1149.5. there is only a rfc 1149 (specifying "standard for the transmission of ip datagrams on avia" - an april's joke rfc):

http://www.faqs.org/rfcs/rfc1149.html

but this rfc has no section 5 and does not define a standard ieee-vetted random number as the comment in

http://xkcd.com/221/

claims.

i will not stand for blasphemy against vi.
:-) electrical engineers can be certified, but it is more for working with power systems.

one of the biggest reasons for having a professional engineer certification is to do with liability in case something goes wrong.  so, if you are in a field where a fuckup is unlikely to kill people, there is no need for having a pe certification.  another strike against it in the computer industry, is that the technology is evolving so quickly it is hard to say what is "good practice" right now.  just to give you a for example, chip designers are starting to adopt practices like unit testing and automated regression testing from software engineering to improve reliability.  software people often think hardware guys are some kind of geniuses because they produce such reliable hardware.  if only they knew that the hardware guys also think the software guys are some kind of geniuses because they get so much done so quickly with so few engineers :-)
did you really want to share this? let alone put it on github?
snps are nice, but in about 5 years, time, i think we'll have full personal genome sequencing available for around $1k. i'm glad someone's testing the waters now, so that by the time everyone and their mom (x-linked genes!) is sequenced, we'll have concrete examples of how this goes wrong.
what? how does having the client store a hash instead of a badly-encrypted password increase the workload on the servers?
kinda.  you can log into the game (which you could already do since the password is saved), but you couldn't login to the website (and potentially change the password).

adding a salt (such as your username) to the password and a reasonably secure hash function would break any rainbow table, so stealing your password to login to the website and do nasty stuff would be near impossible.

it may not be the most secure system, but it's much better, and trivial to implement.  the only thing potentially more secure would be using login cookies.
and then gives them each their own operator symbol, so the list of operators grows and grows.

pretty soon, you will need a apl space-cadet keyboard, and 3 others plugged in just to get all the operators perl uses.

any language that needs one of these is clearly deranged. its made for aspies, who love rules minutae, like those obsessive kids who are addicted to mtg or pokemon.

what language needs this?

http://glyphic.s3.amazonaws.com/ozone/mark/periodic/periodic%20table%20of%20the%20operators%20a4%20300dpi.jpg

perl isn't a joke. perl is one of the most alcohol friendly languages around.
sorry, i use python a lot and sometimes forget how to do c#.
it's because the blocks have a common interface. interfaces are a series of functions so a function must provide this number. the random number generator is given because some blocks require it.

this way the code can generate dropped items from a block without having to know what specific type of block it is.

here's some pseudocode i pulled out my ass as an example:

    if (block.destroyed())
    {
      int dropcount = block.quantitydropped(random);
      for (int drop = 0; drop &lt; dropcount; ++drop)
        additem(block.createdropitem());
    }

this information does not refute my point or contribute to the discussion, and i still feel as though you're arguing with somebody else.
most c++ programmers already refuse to use many c++ features, so that will be nothing new. and even if you use nothing of the new features, there's some goodies like fixing &gt;&gt; which everybody likes. in this respect it is like c99: i know nobody who uses complex, but everyone uses the improved variable definitions.

of course that assumes there's no compatibility risk from adoption, and as the article discusses, there is real risk, which means popular template libraries will have to be made to work in both modes. it will be interesting to see how adoption proceeds, but i can tell you that we're in no rush to adopt at work.
1. has a huge dependency that i wasn't willing to live with: posix.

2. makes syscalls even in the fastpath.
write a etl job to take in the shitty imports and transform it into a sane schema.

why penalize all of the read queries, when you can just penalize the one write query.

emulator or real hardware?


let me quote from my web site:


"your assumption is that losethos is for pathetic hardware because of the graphics?  nope, it 
requires a minimum of, like, a x86_64 2.0 ghz cpu.  it's the best you can do without gpu 
acceleration.  see losethos graphics.  emulators are like running on pathetic hardware, so 
run it directly or use vmware.  it's not very power efficient for laptops, either."


way too much shit on the screen, i agree
&gt;b+tress can be explained in 5 minutes without using any terminology other than "array".

ok. please explain b-trees without using any terminology aside from array. 


thinking or calling someone else a sinner is a sin in christianity. remove the log from your own eye before pointing out the splinter in your brothers and all that. also, judgement is left up to god. 

nb, i am a atheist, but the above beliefs are a core tenet that most christians get wrong. the early church fathers wrote extensively about this, because arguing over who is more saved than who, or who is more of a sinner than someone else, was felt to lead to pride ( i'm obviously more saved than he is! ) which was felt to be a deadly sin, or tear churches apart in recrimination. or they worried that feeling you were saved would lead to a backsliding on the path to salvation, a false sense of safety, and a lack of spiritual progress.

so by even uttering it from his lips, larry is showing a big flaw. besides, there might be a alcoholic out there, who while in one way is more of a sinner than larry, may also carry out good works that shadow anything he has ever done. 

basically "don't judge a book by its cover", "judge not, lest ye be judged (god will judge you on how you treat others)", "remove the log from your own eye before complaining about the speck in your brothers (we're all broken in different  ways )"

protestant groups tend to be a lot more into "we're saved we are better than you". catholics/ orthodox tend to be "we're all broken in different ways", and this shows up even in stories about the saints, who were never perfect people. 
the teachings vary by church too, which makes it even more confusing. most christians then don't even believe in the specific tents of their church!
i have a feeling the incremental maintenance of the structure will be tricky, and also the layout across data blocks.

use function based indexes.

create index colx on table using btree col;

create index col_reversex on table using btree reverse(col);

--

select col from table where col like 'foo%'; // fast

select col from table where col like '%bar'; // slow

select col from table where reverse(col) like reverse('%bar'); //fast
i wish i was awesome like you and could judge the efficiency of a design from only one function that takes an object reference as a parameter... oh well...
&gt; summary
&gt; courgette transforms the input into an alternate form where binary diffing is more effective, does the differential compression in the transformed space, and inverts the transform to get the patched output in the original format.

this ^^^^^ is, in essence, the only thing i learned in 7 years of engineering school: many different ways to transform a hard problem into an easier problem, solve the easier problem, then transform it back.
[perl](http://search.cpan.org/perldoc?acme::inline::perl) is a descendent of php.
if it can be done, do it. i'll benchmark the two if you write an abi-compatible pipe.c, which should be trivial if this is true. i just tried it, and it's a bit more complicated than you'd think.

or it's not, and i just fail at reading the man. prove me silly! just rm pipe.c and fill out the api.
even if there were optional features, the way language works by default is important. one of the major good parts of c++ is that writing fast code is easy, and having to do special rituals to make a simple struct as fast as std::pair would be agains that goal.
hi everyone!

i wanted an excuse to try out r, and this is what i came up with. i'm not a mathematician, but this was a simple way for me to play with some r. if you're interested in started, i found this tutorial immensely helpful:

http://www.cyclismo.org/tutorial/r/

i'd love to hear about some of the other reasons people are using r!
because gawker media redesigned all their sites.
downvotes for all gizmodo + child sites until they change the layout to something useable
i see what you are saying, and it is sufficiently tricky. 
to be fair, i wouldn't call hershey's "chocolate".
ordinary xcode, the one bundled with the os, still does. with the iphone, though, they started releasing modified xcodes with iphone sdk attached very quickly. it looks like they'll attempt to return to something saner with xcode 4, as it looks like it supports updating components separately.
have the minecraft server hold the one-way hash of a users password. then when the user tries to log in, make the client use the same hashing algorithm that the server's hash used to hash their entered password. send the entered hash to the server, if they match then log in.
researchers tried to automatically parallelize programs for a long time with limited success. it is easier to design a programming language that allows developers to provide "hints" to the compiler, specifying the parallelization details (see high performance fortran). 
the free lunch is over, meaning that your programs will not necessarily run faster only because of an hardware upgrade, and parallel programming is therefore gonna become more and more important because of multicore cpus, gpus and so on.

that being said, parallel programming is indeed not easy, but i think it's also quite fun. :)
it is not that hard in verilog or vhdl.

all the hdl (hardware description languages) solved this problem ages ago.
it is not hard per-se, you just need a good simulator to make sure it's doing what you think its doing.

it is harder than high-level languages though.
&gt;we can just use one field for everything.  its simpler and more flexible.

--some jackass that was there before you
of those, css gradients and maybe text-shadow are two i'm really missing cos it's really fucking noticable!
you must have a fantastic ass. also, i've just started learning about interfaces in my cs class and my teacher has yet to provide us with a logical example of one. this may have been what i've been looking for. 
it's [tex](http://en.wikipedia.org/wiki/tex) that's approaching pi. [latex](http://en.wikipedia.org/wiki/latex) is built upon tex and i guess is still in active development.
when using a function (e.g. upper) in the where clause, will the index be used at all? at least with mysql and myisam tables the index doesn't seem to be used.
you would need a function based index on an expression like 'upper(last_name)'.

mysql doesn't support function based indexes, unfortunately. so, that sample doesn't apply well for mysql.

here is the related chapter in my book: http://use-the-index-luke.com/sql/where-clause/functions
it's fine if they want to push it, but i hate having to download several gb of data every update for their games. from their own sales it's estimated they brought in $80 million last year. and a magical $1 billion from internet e-statistics: http://gamrconnect.vgchartz.com/thread.php?id=124061 i would say they have the money to make their client work better. portal alone brought in $20 million in 2010. valve is valve, they do what they want, when they want to. fortunately they usually are pretty nice about things.
like gcc -std option which specifies which standard gcc should follow when compiling code

http://gcc.gnu.org/onlinedocs/gcc/standards.html
there are open source wrappers for libspotify supporting c#, c++ and java:

* https://github.com/jonasl/libspotify-sharp
* http://code.google.com/p/libspotify-plusplus/
* http://code.google.com/p/jlibspotify/



god dammit i lose
nope!

doesn't seem to much interest in this thread, so all it does it try over and over to create a working 3x3 magic square. the numbers are random so i've seen attempt numbers from 10 to 669
it's polymorphism. all of the classes have the same interface and you don't need to know which one you're dealing with.

like if all vehicles have a "drive" method which might take gasoline as a parameter, the bicycle might ignore the gasoline parameter because it doesn't need it, but the car will use it. (this analogy breaks down if you start talking about hydrogen-powered vehicles of course...then you probably need another layer of polymorphism)
&gt; if this method returns the number of snowballs returned from one block of snow, why not just store the number as a constant or a private variable somewhere?

it is probably a constant, but it's been inlined either by the compiler or the obfuscator.

&gt; i still feel as though you're arguing with somebody else.

cognitive dissonance is a powerful defense mechanism.
well, one point would be the seamless way in which parallel data structures and operations are supported in the libraries.

in the real world parallel programming is often too cumbersome to use even if the algorithm/operation is embarrassingly parallel, because it requires extensive reworking of the code. scala changes that.

trivial examples:
    array(1,2,3,4,5)     map (2*) filter (3&lt;) sum  //sequential (cpu)
    array(1,2,3,4,5).par map (2*) filter (3&lt;) sum  //parallel (cpu)
    array(1,2,3,4,5).cl  map (2*) filter (3&lt;) sum  //parallel (gpu, opencl) with third party library

additionally, the group around odersky got a grant (afaik 2.3 million €) to work on polymorphic embeddings, which means that code is saved as an abstract dataflow graph into the bytecode and can decide itself at runtime what the most efficient execution strategy is (like running on the gpu; running on the jvm; creating c code, compiling it with a c compiler and executing it; ...).
it could be compared to another, specialized jit compiler, but it is much more advanced.

scalacl: http://code.google.com/p/scalacl/

eu grant: http://www.scala-lang.org/node/8579
originally, there were 5 or so downvotes and no upvotes, and this was 7 hours after the article was submitted.
i believe it's being passed the random number *generator* , which it then calls .nextint(2) on.
i find that acyclic finite state transducers rust easily, and prefer the longer lasting carbon based transducers.
v jbhyq fnl fvapr zbfg crbcyr qvqa'g obgure gb ha-ebg13 guvf grkg fubjf gung rapelcgvat gur cnffjbeq qbrf nqq fbzr cebgrpgvba.
that was my first thought.

my second thought was "why won't this window close?" :(
ugh, i get this all the time.  people are convinced that "interpreted language" = "scripting language".
hm, comparing performance would actually be interesting.
ntteningrq erfgngrzrag: vs gurl unir npprff gb lbhe ynfgybtva svyr, gurl nyernql unir npprff gb lbhe svyrflfgrz, naq guhf ner nyzbfg pregnvayl oernxvat gur ynj.

haarprffnel pynevsvpngvba: vs gurl ner nyernql oernxvat gur ynj gb nggnpx lbh, gura gurl ner dhvgr yvxryl gb fcraq gur gvzr gb oernx zrnavatyrff cebgrpgvba.
thanks for the link...for a second there i thought you were making some kind of joke that would involve triaxillating deflector arrays or something.
not sure who downvoted you - it looks like this is like the "save my password" feature in firefox. it must save the password in a reversible way in order to prefill it later; the client is not doing the authentication.
i've just tried to fix the windows condition variables. they're now dead-simple and i'd appreciate it if you took a look :)

https://github.com/wowus/pipe/blob/18ed513fe3c1dc5fad65d9f997d79ec0965e8983/pipe.c#l121
that definition is much worse than many others.  there are plenty of examples of large applications that run entirely, or in large part, on interpreted code.  these are not "scripts".  on the other hand, i've written plenty of 1 page c programs to automate a simple task.  that's a script, even if it's compiled.
please come from hersheys
i just told you the gist of how to do it. fill in the rest. i'm not sure what your complication is, but if you think about blocking i/o, you must of course make the pipe unblocking and use an i/o notification method on the pipe (e.g. select/kqueue/epoll) for read.
[those numbers aren't real.](http://www.reddit.com/r/wtf/comments/eaqnf/pardon_me_but_5000_downvotes_wtf_is_worldnews_for/c16omup)
i'd `gg=g` that.
&gt; i disagree that you should only charge for time that you are coding.

yup. i don't charge for coding. i charge for thinking.
&gt; has a huge dependency that i wasn't willing to live with: posix.

ah yes, and the p in pthread which you use stands for...? 
you're smart.
sup dawg.
vs2010 is also free if you get the express editions and while i've never used eclipse, i highly doubt it has the same level of integration with c# that vs2010 does.
eh, don't worry about it :)
i've done work for the government and it actually is very strict.  read about cmmi capability maturity model integration.  to work on government level projects your organization must usually be a cmmi level 5. 
i think this is because it's more like documentation rather than a blog post, or something similar.
ohh, thanks for that link, i was always baffled by why the up/down votes seemed to be inconsistent over time
&gt; all of the missing features you mentioned do not require any overhead in programs which don't use them

for pthreads, this is demonstrably not true.  see bionic's overview.txt for an explanation.  locale-dependent formatting also seems like something that does add overhead, though i haven't looked at the details.  edit: i think c++ support requires a bit of work too.

i'm also very skeptical that a complete (and accurate!) c99 math library is only 150k of code.  heck, i'm skeptical that some of the above features fit into 20k of code.  but i'm happy to be proven wrong.
&gt;i’ve thought long and hard about each of those questions

hehe

by your argument, there are *too many elements* in chemistry, too.
perhaps in your small world.
on the database that i worked on, this example search would have been implemented using our substring index. and possibly an equality index. here's how it worked:

the database maintains an index of all 3-letter substrings of the field in question. so, a word like 'apple' would have an entry for app, ppl, and ple.

when a 'like' query comes in, we would query the index for the index rows which match the query, find the intersection, then do additional processing using the equality index to find the result.
sounds like you are describing perl 4.
i think the article is missing a paragraph about *why* like can't simply do a full-text search on the index itself. (sorry if it's somewhere else in the blog/book, but even then it would warrant a mention here.)

now that i think about it, i realize that an index is a b-tree (i did learn about those in comp. sci., but i *hated* that part of the curriculum, so...), but i have to admit that until now i'd always conceived of the index as a kind of mini-table that would just have one field (or several), within which it would have made perfect sense to perform a like or any other operation.

(for the record, that doesn't mean i put likes everywhere in my queries.)
i think it can only help. if you truly understand sql, go ahead and list it on your resume as a skill. try and learn as much as you can before then though, you don't want to be caught with your pants down by a technically-minded interviewer. you might as well try to build a simple php web application too, with an sql database (make sure you learn about escaping your inputs!). i think knowing that stuff shows a high level of technical skill and intelligence that would be valuable in any field.
with servlet 3.0, it now can take zero lines.
if you need an explanation for that - you're in the wrong profession, seriously.
because unlike a for loop, i like to use set logic whenever possible. databases have for loops too (cursor) that you should avoid at all costs. that is the base concept your average developer isn't exposed to.

the easiest way to performance tune sql is to:
1) use proper join statements.
2) order your table references to place your smaller datasets first.
3) place your most likely limits first (or the most likely sargable/indexed first)


i'm waiting to see what happens with red bend's lawsuit (http://dockets.justia.com/docket/massachusetts/madce/1:2009cv11813/125212/) before i comment on courgette.
&gt; (this analogy breaks down if you start talking about hydrogen-powered vehicles of course...then you probably need another layer of polymorphism)

yeah, but that's easy. just change all of the drive methods to take a fuel object, and then make gas/hydrogen/electric/ whatever else extend from fuel.

you could make it an interface too, but i think that inheritance fits this particular problem better.

isn't object oriented programming fun? :)
i've commented on [here](http://www.reddit.com/r/funny/comments/fkixv/guy_uploads_his_genome_to_github_another_forks_it/):

&gt; it's not his entire genome, just the single nucleotide polymorphisms 23andme supports. the rs#s refers to its dbsnp reference number. my understanding of the process is that various sources detect places where two humans are known to have a single base (a, t, g or c) different from each other (since most of our dna is the same). that is submitted to a snp database, so eventually we'll have nearly every possible place one human's dna can be different from another's.
however, these seem more like configuration options to me, instead of anything that can described as the whole code. you're not going to be able to make anyone grow wings just with these "configuration options".

that being said, i'm running `diff --speed-large-files --minimal --unified manusporny-genome.txt genome_kernel_task_full_20110213.txt` right now. :p

update:

    $ grep -c "\-rs" diff-with-manu.diff
    422409
    $ grep -c "^rs" /tmp/dna/manusporny-genome.txt
    956728
cool! it runs *bogosort* in constant time!
&gt; no utf8.

it not "no utf8", it's "nothing besides utf8".
that really is the best part of it all.

other (more brilliant guy) forks the project then issues a bunch of pull requests:

  * *eyelids now close in proper way. fixes issue #42*
  * *workaround for temporal lobe being a pile of fail.*

brilliant comedy or a sign of the things to come, you choose....
i don't know how to do it. again, i tried. i'd love to be proven wrong though.
yeah, this post really confused me. i was scratching my head thinking, "am i really that dumb with reading java?"
posix. and the x in posix stands for...
"keep in mind that child is still you...simply the **best** of you"
                                           - geneticist, gattaca
cool!  i thought you had to buy an expert sex-change to see them.
gehr, ohg vg qbrf zvgvtngr pnfhny cnffjbeq guvrirel.
wow, i thought everyone knew this.
it's really hard to manual qa in this queue style. you absolutely need a full regression of automated tests with every change using cd.

if you make a commit, and it's now ready to be deployed after qa verifies, what does qa check? every positive and negative test case and edge case? that could take an hour, then they are saying 25 changes go out a day. 

you can't use manual qa, you trust devs to write automatic tests, and hold them responsible. if they keep pushing stuff that breaks the build, they need to get heavy qa before release.
point still stands, though; sometimes the only documentation that i can find (and understand quickly) are the informal blog posts.
does this mean that they have to provide an update file from any version to any other version? or do users need to linearly progress through each of the patches? 

i.e. if you want to upgrade from 201 to 205, does chrome provide consolidated_patch_201_to_205,  or patch_201, patch_202,... patch_205 which chrome applies in order? 
it has not been overturned yet, it's just been delayed pending review.
dumb dumb dumb, and it still seems clear you don't know anything about the business.

#1, google is an advertising *platform*. they don't create ads. they're just the platform that delivers the ad content. when's the last time clear channel communciations (billboards) gave away freebies to highlight their service?

*advertisters* give away freebies. that's why you can get lots of pepsi swag or activision swag when you go to conventions - they're the ones who have a product to sell, and they give out relatively inexpensive freebies as an advertisement (if someone buys a $50 blizzard game, that easily pays for the $5 it cost to print a tshirt).

&gt; ask microsoft about their windows phone. end-users are more important than developers. ask apple about their iphone 1.0.

sure. look at apple's wildly successful case. can you cite a single instance when they gave away iphones to boost their userbase numbers?

&gt; users attract developers, developers do not attract users, ask google about gears and wave.

wrong on two counts. 1. with this example, do you think it makes sense to say, "if google releases 1000 free phones to regular users in the wild, this will really expand the android userbase and thus attract developers"

developers attract users. that's why palm/hp's webos is a *complete* non-entity these days. it's a highly competitive platform, and a lot of people love and swear by it over ios and android. but there are no developers for it, thus no apps for it, thus no users for it.
the idea that anyone who uses windows and sql server are less technically astute is silly.  there are a great number of good reasons for using microsoft's platform, some of which are in the control of development/technical staff at a company, and some of which are ultimately not.

i'd venture to guess that most people here have used several platforms during their career.  "your typical windows/sql-server crowd" are often people looking for the best solution for the particular problem at hand, just like i would hope that you are.  
because there might be a true, rational religion.
obviously unix pipe is a new concept for you and you need validation that it works at least as good as your pipe implementation and within the same intended problem domain. sure, i'll help. take a look at e.g. the varnish code which uses unix pipe to handle of data between threads. 

for instance, http://varnish-cache.org/svn/trunk/varnish-cache/bin/varnishd/cache_acceptor.c
md5 with a salt is considered decent and i dont know it correctly but that is how linux implements it i guess, it becomes tiresome to use rainbow tables unless the salt is known
yes, i'm sure that can (and does) happen.  but that's what tdd, integration testing, and automated qa are for.

i notice that most proponents of cd are among those who practice it, and most of the naysayers are among those who have never given it a good try but have read an article (or two or ten) on it.

the pope tells everyone that sex is bad, know what i mean?

no, that attitude is a tribal hold-over where someone doing something better with something else is competing for food and bitches, and they need to dominate the situation some other way.

the shit coming out of their mouths is fud.
https://github.com/wowus/pipe/blob/single_mutex/pipe.c#l150
don't know if this is relevant, but there are lots of is jobs that aren't hard core cs through and through. there are plenty of server admin types that think they are a god because they can write a small win script. i would say that there is something to be said for this article but it's not a all or nothing situation. you might not be able to hard code in c++ but there are lots of demands for great cs people in other facets of it. 
here's a tip, bro.
https://spreadsheets.google.com/ccc?key=0agpl2o82xx1pdfp2snqxzunuvwvjehl0egrsdnrdngc&amp;hl=en&amp;authkey=cjvxgkgm#gid=12
don't worry too much about it; i doubt that even reflection (let alone the bytecode format) is covered in a first-year course. most of my knowledge of this stuff comes from my minecraft modding work, and i've been programming java professionally for 9 years :)
it falls back on them. it's used on systems that have nothing else.
logged in just to respond to this patronizing crap.

it's pretty clear to anyone reading that he's right and you're wrong. there's no reason to demean the guy just because being incorrect hurt your ego.
i thought about also submitting this to [/r/linguistics](/r/linguistics) but it i figured it was a bit too trivial for their taste
fwiw, the mcp uses jad for the most part and patches in bits done with jd and/or fernflower (another decompilation tool) if i remember correctly. jad (and for that matter, jd) don't understand anything about java 5 features like enums and generics so it's a fairly painful process to get from a new minecraft version to a useable decompiled one. to be fair, java bytecode doesn't understand generics either :)
does this mean trying to patent genetic code is no longer possible?
wait a fuck.  that sounds bad either way.
'4' could be #define'd somewhere as well.

edit: whoops, missed the fact that this was java.  doesn't really matter, as i was thinking of compile-time macros in general, and there are ways to extend the jdk compiler to use macros.  i just say "#define"'s because i learned c as my first language and the nomenclature is stuck in my head.

i guess some people thought i was opposing bdunderscore's comment, but i was agreeing and adding to it. (yes, i know macros won't show up in pre-compiled code, which was my point...)
yes, but seeing how far the mcp has come already with decoding the entire thing, notch may as well give up and save everybody a lot of hassle. as a modder, i've started dreading new releases...

those that want to mod, will. 90% (if not more) of minecraft players doesn't even know java anyway!
yep, thats what i was trying to point out.  nicely done btw.
okay, yah. sorry ents. i do a sunday wake and bake, so yah.
i'd still rather have a "block and report spam" button to smash whenever i see them pop up in search results.
hey everybody, this guy runs windows xp in fisher-price mode
that code requires a lot of context i don't have. i see 0 calls to read(), and 1 call to write() inside an assert. i really don't want to go learn the varnish codebase just to continue this discussion, so would you mind just filling out my api using only unix sockets? it's not that complicated: 9 functions, 5 of which should be trivial.
how accurate is the data from 23andme? i don't know much about genetics. are there checksums in it?

edit: also, [how do you know the data is yours?](http://blogs.nature.com/news/thegreatbeyond/2010/06/consumer_genomics_company_snaf_1.html)

and a protip: never link this data to your real name. an employer can look at it and reject you because of certain risks. if not today, then in 5 years
this is actually something i approached my boss about last week, we just have to get approval back from the sas to actually do it. or just let them do it, haha.
i'm learning java to be specific. how exactly are interfaces called? here, going off on the minecraft example:
    public interface block{
        public void setblock(int i);
        public void removeblock(int i);
    }
and then you'd have a gravel, dirt, sand, and rock class, each of which have two corresponding functions to those two. i still don't quite understand why you wouldn't say something like 
    gravel.removeblock(3); //total pseudocode
you do realise the same wiki has [a much longer general list of esoteric languages](http://esoteric.voxelperfect.net/wiki/language_list)?
yeah, "just" a parser... parsing natural language and extracting the important information is a very hard problem.
that would be a good strategy. i usually go for the most direct means, which covers 4 cases. your method just combines two of them.
too verbose, surely you can do better than an imperative language!
lol i guess he isn't a leet hacker that can switch it back to classic mode via the desktop appearance gui.
&gt; you stop a good percentage of people from easily getting your password

not the ones that count.
the domain name is esolangs.org for a reason.
perl: there is more than one way to do it wrong
hint, your link is not about programming.

not an incremental update. it's a complete disk image.
i'm surprised by how many people still don't know this.
i've never actually tried it. 

where i work we have enough live test hardware to tee some traffic to it and see if it's operating as expected without hitting the live system. 

the procedure as described in the article is terrifying
yeah, it's magic. it updates completely seamlessly.

unlike firefox, which makes you wait 5 minutes for the update to install, and consequently i usually skipped it.
o' reilly: you can't explain that.
in java?
&gt; the idea that anyone who uses windows and sql server are less technically astute is silly. 

nah, i'll stand behind that.  go to a major university and look at their programs, go to a leading edge technology conference and look at what technology they're using - it's linux in most cases besides gaming.

windows is now like the mainframe within the corporate world:  well-established, but not very innovative, worked on by vast numbers of not-so-enthusiastic developers.

and of course, i hope this doesn't sound like i'm saying that there aren't really talented people working with microsoft technology.  there definitely are.   but i seldom meet enthusiasts on that platform.
but then you don't need to reverse it in the first place, since the hash is now as good as the password. you've negated the benefit of hashing server side.
just submit the question to something like serverfault or stackoverflow instead.  you'll be doing yourself and others like you a favor.
only if you're coming from a search engine.
this is so stupid
the problem is that not all databases support those, though. most developers who have only used mysql, for instance, wouldn't even have any idea that such a thing could exist!
i still see 'expert sex change' when i see the url.
shouldn't it at least be 42?
you refute this fact?
no, he's not talking about the various database-specific extensions that let one use looping alongside sql queries within stored procedures or something like that.

he's talking about how the database itself actually executes queries internally. understanding what it's actually doing is what's important.
oh my god its almost as if physics is useful in representing physical entities....
ah, cool, nice work. : ) this is the first time i've wandered through the decompiled code for minecraft and when i saw this, i instantly thought xkcd. the opportunity to make an xkcd joke whether it was notch's intention or not was too good to pass up. it surely does make sense to have a method that manipulates a random to get the number it needs, whether the number's random or not. ; p

i'd guess, then, that the pj class is block and this is an inherited method.
what the fuck are you talking about? compatibility is one of the things that those creating the c++ specs, as well as the most important implementations, take very seriously.

besides, them using the new features ***within*** their standard libraries has absolutely no impact on anyone using those libraries. it's an internal implementation detail hidden by the standard library's api. you do realize that that is one of the benefits of oop, right?
is there some sort of documentation for minecraft online? and if not can you take a crack at it? i know i've many a time delved into the obfuscation but never got far. 
c# 5? version 4 came with parallel linq. version 5 will have async syntax, but async doesn't necessary mean multi-threaded.
right, i'm advocating the use of ajax.  #'s in urls allow the back/forward button to work, bookmarking to work, and for natural links &lt;a hrefs&gt; that perform ajax activities.

all of the downsides that are pointed out about # urls are concerns about ajax, and while # doesn't solve all of the ajax problems, it does solve some, and it is in no way worse than a fully ajax page that doesn't use #s.

i'm aware sofea.net does not *currently* function with noscript on, i don't have the server side rendering turned on yet, but if you're interested, i'll send you a pm when i do turn it on so you can see how it will work.

the rendering does work already, it's just a matter of working out some scoping kinks to allow multiple requests to a server side handler concurrently that i'm still working on. 
u mad bro?
the system requirements of the game is evidence enough of the efficiency behind the scenes.
how many web bubbles will need to burst before fools like you begin to realize the importance of making business ventures profitable?
i cannot imagine doing non-trivial multi-threaded applications in a non-gc language. clearly it can be done, but without extensive copying i cannot see how they can properly handle memory management. 
    select * from small_table_that_will_become_a_massive_table;

&gt; see mysql is super easy, now you just loop over it with whatever language you want to use and filter out what you need.

noob developers first database driven project.


sadly, i'm guilty of this.
&gt; this fails for my tail recursion tests. i noted that the subject had an actual vestigial tail, attached to another tail, etc.
*warning, not a programmer in the slightest, just asking for advice*

so i can see his computer name in my osx sharing panel, its also *his* name ie "bobby davro's imac"... first time he's done that but i've suspected my wifi has been cracked before due to slow downs and have changed the pass.  this guy must have some sort of brute force crack app no?

anyway, i googled his name and got his facebook page.  90% sure who it is but i need some sort of undeniable proof, 

ideas anyone?

n-n-n-not programming.
watched [this](http://video.pbs.org/video/1786674622/) a few days ago. pretty interesting.

edit: it's a nova special on the computer that's going to be playing
apparently it's straightforward enough for google to figure it out
i do.
use wpa2 and change your password every day. he'll give up soon enough. the best revenge is a life well-lived.
because large amounts of the code have to generalise to any type of block that could occur. so if they need to get a particular thing relating to that block type, a method that returns the correct number means that the code doesn't have to know what type of block it is, it just has to assume that the block knows the right data - which it does.
no, he's trying to say that anyone that's taken a basic cs course can understand what's happening internally in the database.

the only thing that's important to understand when querying a database is what the dbms will use when looking for potential indexes and what limits will cause full table scans. this article explains quite well why like can be a terrible performer (also the reason why you want to use equals instead of not equals; or in instead of not in).

his last sentence about dbas and report writers is also an incorrect assumption. what is the importance of a for loop to writing a report? a report writer should never write a report around loops. 

if i were to reverse his position it would be "there should not be a such a thing as an application developer who can't write a well formed query and so can't understand what the power of a database is."

that's an idiotic statement as there are already sooo many devs that think a database is only a persistence layer for the important thing (the application); my belief is that the applications are the completely replaceable pieces as long as the data itself is sound.
that's not how inlining works. inlining would be where a line of code references a constant in the original source, but that constant is directly replaced with its value in the compiled code (since the constant can't change without changing the source, so it _must_ be the same every time it's referenced).
i hide this in major releases for fun:

    class evilint(int):
        freq = random.randint(1000, 10000)
        i = 0
        def __add__(self, other):
            evilint.i += 1
            if evilint.i == freq:
                evilint.i = 0
                return random.randint(-5, 100)
            else:
                return int.__add__(self, other)
prashant deva! good luck my friend, nice to see your head pop up again.
every proper browser.
thanks!
yeah, last time that happened with ended up with unix and c.
some combination of a computer with 2 network cards, with os nat sharing with your wireless router using only the switched ports (not wan), which puts all traffic through the computer. use wireshark, tcpdump, or an appropriate diagnostic and logging suite to log all traffic.  alternatively, use a separate wireless interface to sniff and decrypt his wireless traffic off the air (potentially less cumbersome and more transparent but less reliable than the aforementioned setup).

tl;dr call jack@ctu, they can open a socket on the router.  good luck.  i hope you get him
the good thing about mysql is that it's free and fairly ubiquitous.  it's decent for small databases, especially if it means people stop using ms access for everything regardless of scale.
aww, damn, i'm surprised people didn't gobble this thread up. i tried working on my little layout helper class drunk the other night (also in as3; i get sick of manually keeping track of y/x positions when i'm trying to create a simple dynamic multi-object layout), but somehow had the presence of mind to stop what i was doing so i don't destroy all of the prior day's hard work with drunken gibberish.

anyway, thanks for sharing!
&gt; he's a border line dolt who plays with a lot of other peoples money.

he's got a degree in mechanical engineering from mit, an mba from the wharton school, and manages more than $100 million in capital.

what about you?
i haven't used qt enough to comment, but regarding gtk+: dead on.

i'll say this: real-world gtk+ code is the only code i can think of that blends the clarity of perl with the terseness of java.
explain?
butthurt enterprise java jockey.
change your wifi broadcast name and make it stop broadcasting its name (that is, you need to know the ssid to connect). then set up a better password as well.    
don't confront them, it will bring nothing of worth. 
perhaps we need to figure out a standard way to list attributes with the genetic data. if we have a lot of people with their genetic data, and a list of attributes, imagine all the statistical techniques we could use on it!
why was wp7 chosen over meego? meego would work in tablets etc., many android applications can be easily adjusted to meego. it is a huge ecosystem compared to wp7. even in current aplha stage meego seems more mature and features rich platform than wp7 is. qt and meego were the right direction and now all is halted. plenty of good work gone to waste. i undrestand the killing of symbian, but not in favour of wp7. resources should have been shifted from symbian to meego to get it out faster. also even symbian was doing way better than wp7 so why switch to a much inferior system? what exactly does nokia gain here? nothing. ms has everything to gain. this was a bad move, which will bring nokia down very fast. also way to go burning your relationship with intel, you know they could have had some intresting mobile processor coming soon and nokia would have been first to get them.

now i see more ms employees coming to nokia. this really isn't anything more than a carefully taught company overtake from ms.
&gt;go to a major university and look at their programs, go to a leading edge technology conference and look at what technology they're using - it's linux in most cases besides gaming.

as is so often pointed out here:  correlation does not imply causation.  the fact that a lot of people doing interesting work are not targeting windows does not by itself imply that interesting work can not be done (or is not being done) using windows.  

oftentimes in academia and in the startup world, microsoft is avoided because of cost.  that is far from the only reason, but it is certainly the predominant reason.  if you're working on a project that involves multi-server scalability or very large amounts of data, and you are an academic or a startup without incredible funding, buying 30 copies of windows server 2008 and 10 copies of sql server data center edition is not feasible.  often in spite of the discounts and programs to help n these situations.  on cost, you can't beat free.

&gt;well-established, but not very innovative

only if you completely ignore microsoft research, f#, parallel programming work being done in the .net platform entirely, microsoft surface, and a slew of other projects.

&gt;worked on by vast numbers of not-so-enthusiastic developers.

&gt;but i seldom meet enthusiasts on that platform.

among the many technologies that i do work with, and in spite of the stigma that it buys me with the hive mind, i will tell you that you are talking to someone who is very enthusiastic and very happy to be working with microsoft's platform and particularly with microsoft's development tools.  

i've met many others who would say the same.  you won't see them posting that here.  deliberate or not and regardless of motivations, open online communities as a whole have made it politically incorrect and unacceptable to say anything that even hints at support or appreciation of any tools or platforms with the name "microsoft" on them.

you haven't met many enthusiasts, because they are quickly silenced, downvoted and flamed until they learn that you just don't say nice things about microsoft outside of close communities.


intellitrace ripoff
you wouldn't consider intercal to be in the joke languages subset?
except jeopardy is very english. just think of all the puns that are on jeopardy alone, and how difficult non-native english speakers have with them.
this article is accurate, however the reasons that like can be slow actually has to do with sargs (search args) and if your query predicate is sargable (as defined in "access path selection in a relational database management system" by p. selinger et al, which is pretty much the defining research paper in this area).  it basically states that an argument which evaluates as a boolean operation and defines a specific range of values is saragable (word made up in the paper).  therefore "where x = 10" is sargable, since 10 is a range (10 to 10).  "where x &lt; 10) is also a range, as is where name = 'a%' because 'a%' specifies a specific range of values that start with aa* and end with ab*.  arguments that do not define a range must be tested against every row, so "where x = myfunction(x)" is not sargable, since the operation "myfunction" would have to be preformed on each row.  also, "where x like '%a'" is not sargable since i have to check every row to see if it end with 'a'.  

so, why is an index faster?  databases work on sets.  by definition, a set is unordered, so the data is stored on the hard drive in whatever order.  an index is effectively a balanced binary tree that organizes ntuples by a particular value defined in said ntuple (actually technically called a "domain" in this case).  it applies an order to that set based on that particular value.  also, the leaf nodes are sideways-linked such that if i perform a search on the tree for a particular value, once i find the leaf containing that value i could just read the entirety of the rest of that table by moving to the right or left from leaf to leaf.  an index typically lives in memory, however.  now, there are two basic kinds:  a clustered and non-clustered index.  

data is stored on the hard drive in pages and individual ntuples live in these pages.  some pages may be full, others may be completely empty or anywhere in between.  if i just try to read data from a table with no index, it has to touch every single non-empty page no matter what.  we want to avoid this if we can.

a non-clustered index stores a pointer to the actual n-tuple record on the hard drive.  therefore, when a non-clustered index is used, the database will only ever touch pages that contain candidate ntuples that we're interested in, however since they could be arranged wherever, those pages may be examined multiple times.  this occurs if two values that are located on the same page are far away from each other in the index (imagine like 'a%' where aa and az are next to each other on the page but would be far away in an index that puts those values in order alphabetically).

a clustered index physically orders the ntuples on the hard drive in the order defined by the index, so as a result the table can be scanned in the same order as the index (this is called a seek in the world of sql).  since the data is in order, a clustered index scan will only ever access pages that contain values in the query and will only ever touch each page once, since in this case "aa" and "az" would be located on the disk wherever they actually belong and would not be next to each other unless they were the only values.

now, technically a database can always use an index to access the data in your query, just like it can always use a table scan to do the same thing, however these things are not always useful.  an index is considered "efficient" if both the argument is sargable and it references a column defined in an index.  this does not, however mean that the index is going to be the optimal access path.  if the query defines some sort of ordering (order by or group by), then it may require a sort, which could affect which index is selected.  also, if joins are involved, they will also affect the access path selected and calculating join ordering is np hard (typically it's n!) in the general case, although there are optimizations possible.  the database tries to optimize everything, but it can't optimize crap, so it's important that you understand precisely what the database is trying to do before you write a random query.

if you want to know precisely what your database is going to do to a particular query, read its query plan and it will tell you what index, if any, is used.  

in this case, we can see that unless the query predicate defines a specific range of values, it is not sargable, and therefore it cannot take advantage of an index.
they seem to look the other way for larry wall, however.
concept from [omniscient debugger](http://www.lambdacs.com/debugger/).
yes, sort of. the [minecraft coder pack](http://mcp.ocean-labs.de/index.php/mcp_releases) is a tool that decompiles and deobfuscates the files. they also have a handy [deobfuscation spreadsheet](https://spreadsheets.google.com/ccc?key=0agpl2o82xx1pdfp2snqxzunuvwvjehl0egrsdnrdngc&amp;hl=en&amp;authkey=cjvxgkgm). here's [another handy site](http://www.tkte.ch/projects/pymy/?cver=1293023696000) to see what the different classes are. people are generally helpful over at [minecraftforum.net](http://www.minecraftforum.net/) as well, especially in the modding section.

this is not proper documentation by notch/mojang though. however, they are working an a modding api.
alternatively, just make a reversed column and index it normally.
this is the kinds of math i learned in physics and engineering classes so you might be right but i think its shared. :)
&gt;cognitive dissonance is a powerful defense mechanism.

you're illustrating that quite effectively, yes.
personally, i use mac filtering to secure my network.  while still not unbeatable, outsiders would have to spoof an approved mac address to get in and alter my security.
everybody was a beginner at some point...
you are correct, pj.class is the basic block class. in pj.class you find this same method returning 1, which is the default. that other function you see in the screenshot determines what to be returned when a block is destroyed:
    public int a(int paramint, random paramrandom) {
        return eo.ab.ba;
   }

in this particular snippet, snow balls are dropped.

edit: you see that random is a parameter here as well, this is used for blocks that have a chance of dropping more than one item, like gravel. with gravel there is chance that flint is dropped instead, hence the random parameter.
the police would love to have a database of voluntarily-submitted genetic data.

perhaps post this in r/techsupport instead?
well, all of the wifi security protocols have weaknesses.  any determined bandwidth leech is going to be able to get on.

even stopping broadcasting your ssid won't help much, there's a way to fish for that too.

make sure you are using wpa2. hide your ssid.  change your password regularly to something hard to brute force.  also enable mac address filtering by programming the mac address of all of your devices into your router and tell it to only communicate with those.

this all can still be circumvented, including the mac addy filter as if you know how you can change the mac addy on a wifi card, but it's probably enough to keep him out.

i wouldn't bother chasing him down or trying to prove anything, it's a pain and probably won't get you anything other than grief.
it's ok; they decided on 4 randomly. it could have been any other number.
python implementation.

edit to point out: "@" is not implemented. if someone finds an actual use for it, i will implement it.

    #! /usr/bin/env python

    # count from 99 to 0!
    program = """
        # 10, a, &amp;                             #
        # -1, a, &amp;                             #
        # b, b, &amp;                              #
        # 10, b, &amp;                             #
        # -1, b, &amp;                             #
        # d, d, &amp;                              #
        # q, q, &amp;                              #
        # c, c, &amp;                              #
        # b, c, &amp;                              #
        # a, q, &amp;                              #
        # -48, q, -1                           #
        # -48, c, -1                           #
        # -10, d, -1                           #
        # e, e, &amp;                              #
        # f, f, &amp;                              #
        # b, e, &amp;                              #
        # e, f, &amp;                              #
        # -1, f, &amp;                             #
        # 0, f, 4                              #
        # g, g, &amp;                              #
        # h, h, &amp;                              #
        # a, g, &amp;                              #
        # g, h, &amp;                              #
        # -1, h, &amp;                             #
        # 0, h, 1                              #
    """

    class operand(object):
        def __init__(self, source, literal):
            self.literal = literal
            if literal:
                self.value = int("".join(source))
            else:
                self.register = ord(source[0]) - ord("a")
                
        @classmethod
        def make_register(cls, string, location, tokens):
            return cls(tokens, literal=false)
        
        @classmethod
        def make_literal(cls, string, location, tokens):
            return cls(tokens, literal=true)
            
        def __repr__(self):
            if self.literal:
                return 'literal(%s)' % self.value
            return 'register(%s)' % chr(self.register + ord("a"))

    class statement(object):
        def __init__(self, op1, op2, dest):
            self.args = self.op1, self.op2, self.dest = op1, op2, dest
            
        @classmethod
        def make(cls, string, location, tokens):
            return cls(*tokens)
            
        def __repr__(self):
            return '&lt;smt op1="%s" op2="%s" dest="%s"&gt;' % self.args

    def parse(program):
        from pyparsing import literal, word, optional, oneormore, nums
        from string import ascii_uppercase
        
        hash = literal("#").suppress()
        comma = literal(",").suppress()

        register = word(ascii_uppercase, max=1)
        register.setparseaction(operand.make_register)
        
        value_literal = optional("-") + word(nums)
        value_literal.setparseaction(operand.make_literal)
        
        op1 = register | value_literal
        op2 = register
        pc_jmp_if_leq = literal("-1") | literal("&amp;") | literal("$") | word(nums)
        
        statement = op1 + comma + op2 + comma + pc_jmp_if_leq
        statement.setparseaction(statement.make)
        
        grammar = oneormore(hash + statement + hash)

        return grammar.parsestring(program).aslist()    

    def execute(code):
        output = []
        registers = [0] * 26
        program_counter = 0
        
        while program_counter &lt; len(code):
            smt = code[program_counter]
            
            val1 = smt.op1.value if smt.op1.literal else registers[smt.op1.register]
            val2 = registers[smt.op2.register]
            
            registers[smt.op2.register] = val2 = val2 - val1
            
            print registers
            
            if smt.dest == "-1":
                output.append(val2)
                
            if val2 &lt;= 0:
                if smt.dest == "$":
                    continue
                elif smt.dest == "&amp;":
                    pass
                else:
                    program_counter = int(smt.dest)
                    continue
                 
            program_counter += 1
            
        return output
        
    def main():
        code = parse(program)
        result = execute(code)
        print "".join(map(chr, result))
        
    main()
not it doesn't, the remote server could just as easily accept a hash to authenticate the copy of the game. sure someone could still steal that hash and log into the game as you, but they wouldn't have your plain text password that they could use to log into the website, mess with your account, change your password etc.
kinematics, the study of motion and trajectories, is indeed part of physics.
hey man it's a really random 4 man...
is this a joke? i think the time to start writing tutorials is somewhere after the point when you've implemented hello fucking world, no?
oh man, this is awesome, too bad it's $199.
haskell all the way down, bitches.
sony hard-coded their random seed, fail0verflow made the xkcd joke: http://xkcd.com/221/
this isn't the function you're looking for.

it's not a random number generator.
i don't understand your point. where is this "universal constant"? also that piece of code does not tell you how the password is stored - its just a pretty standard cipher implementation
what obfuscator is this?
they both thought this was a random number generator. 

fail0verflow, when trying to crack the ps3, discovered that sony used a random number generator that always returned 4.
it just requires making the interfaces very explicit about what happens to scope and ownership. sometimes you copy, sometimes you pass ownership, sometimes you can assume the scope of the item will outlast the other call, and sometimes you just need to ref-count your resources. so long as everything is explicit and clear, memory management is the least of your worries.
i am the same way. i don't exaggerate my abilities and if there is an aspect of the job i am not familiar with i'd just say that i'd devote my time, both on and off the job, to understanding it.

i am not a good bullshitter, but i think my ego offsets that. i exude confidence. not that i am confident that i am perfect for the job, but that i am confident in my abilities that i can adapt to nearly any situation and solve any problem.

only once did i not get a job i really wanted. i talked to the hr person for a followup to see what went wrong and he told me that i didn't ask enough questions about the company which told him i wasn't really excited about working there. curse you, random hr guy!!
since boost can best be characterized as 'c with templates' you are probably right. 
problem? http://i.imgur.com/mu8us.png
don't mind me, just [leaving this here](http://blogs.perl.org/users/su-shee/2011/01/and-suddenly-youre-hip.html).
'compatibility risk' is downplay. c++0x breaks core language semantics. 
disregard trigonometry,
acquire matrix calculations.

seriously, i never touch any trigonometry stuff anymore, everything is abstracted today within matrices, or hidden away in vector math. i only abuse it in shaders :)
i'm not sure what part of bionic's overview.txt you are referring to, but it's irrelevant to musl. if you want to see whether any thread-related overhead gets added in a program linked to musl that's not using threads, simply link a program and use objdump on the resulting binary rather than making ignorant guesses. (you might also use strace to inspect for syscall overheade.) and if you care about a few 30-byte functions that might get linked, i think you'd better forget about c and go write your programs in asm...
indeed. it's the werkkzeug from farbraush, and you can use 3 to spare some bytes and nobody will notice if the model moves fast enough.
    select * from table_that_will_suddenly_have_eight_blob_fields
thanks.  my ap provides a public, open network too, so i do occasionally have new prey with which to toy. :p
    private cipher getcipher(int mode, string password) throws exception {
        random random = new random(43287234l);

this random will give the same sequence of bytes every run, due to the constant seed of 43287234. this means the salt is always the same. also, the password is "passwordfile". 

and it's stored/read [like this](http://www.privatepaste.com/2df013d7f4/alks).
doesn't mean it won't get better. this seems like an interesting concept that will probably be refined over time.
don't worry, it'll be below 100$ in a few years. the price has been crashing (23andme used to sell 550k snps for roughly that price, and hasn't dropped its price much because it instead upped the product and starting selling 1m snps.)
great site. i'm trying to get this going on my project now. i'll be using this site and lot 
upvoted for mode 7.

although you can tell how old the site is because none of the links work.
a good article! there is a second part about texture-mapped cylinders and spheres here: http://www.helixsoft.nl/articles/sphere/sphere.html
want different colors? once you've installed the style, visit codereddit.com, click the stylish icon and select "edit". you're a ~~developer~~ programmer (this is r/programming) - you can do this.
no, not in a context of esoteric programming languages.
fkin fanboys
trig may be useful, but it'll never be cool.
it's a little amusing that you criticize the perl community for not experimenting with new features for the sake of feedback on an evolving specification... when this is exactly what pugs and rakudo were for to begin with.

and sure, everyone agrees that pugs failed miserably, and rakudo took far too long to get off the ground. however, rakudo is now quite healthy and its development is proceeding quickly. claiming it has failed is nonsense.
the website, which allows you to change the password on the account, needs a password to login.
sorry bro, not programming.
whoa, i've been trying to find this article again for years! thanks man.
just like ur momther
no it won't. anything minecraft can do, trojans can do better. as soon as minecraft implemented needing a machine-specific key, a trojan could just do that while on the victim's computer. alternately, it could note down the needed values and upload them along with the encrypted lastlogin file, for future decryption.
thanks for this, i've been looking for a guide on drawing in 3d space!
thanks to the alegro dependency the examples run fine in linux. for those who aren't used to what is needed to get it to work here are some hints: i downloaded liballeg and liballeg-dev packages then i had to alter the makefile slightly to get it to compile. i had to add a "-bsymbolic-functions" option and i changed the "alleg" in libraries to "alleg-4.2.2" because when it said alleg it wanted to link to liballeg.a instead of liballeg.so-4.2.2, rename it to whatever your .so in your distrubution is.


....

    libraries = alleg-4.2.2

....

    options = \

        -o2\

        -ffast-math\

        -fomit-frame-pointer\

        -s\

        -bsymbolic-functions

see http://www.slideshare.net/tim.bunce/perl-myths-200909 - number of jobs was growing in 2009 and python programmers said that perl is dying long before that.
yeah, i'm in programming 2 and the examples for oop &amp; interfaces are just awful.
what was the number used for?
"map" is embarrassingly parallel. it's trivial to parallelize in any language.

the ability to perform run-time specialization for different architectures is trivial. the actual specialization is the hard problem, and largely unsolved to date for anything slightly more complicated than map. the state of the art is in database query optimizers.
os x server is kinda like that.

edit: in more detail, an os x server on a lan connects to apple's network, cacheing software updates for os x clients on the same lan.

having said that, chrome update downloads are automated in the background so you wouldn't notice any speed improvements anyway, and even without diff compression, they are tiny compared to os-wide updates. in other words, excellent diff compression mainly benefits google bandwidth costs rather than benefiting the user in any direct way.
thats what i'm saying, i really doubt tonights episode is going to have those silly categories, or if they do they will be better defined. if not, i would be very impressed if a computer got some of those double meaning questions.
am i the only one not having much problem with this in c++?  we  have a few baseclasses we can re-use for many common multithreaded scenarios.  

for instance if the input is a queue of items that can be processed in parallel, all we have to do is override one pure virtual function to process one item and we have multithreaded processing of those items.
they changed no rules or any other thing for this match. you can watch a practice match [here](http://www.youtube.com/watch?v=12rnbgf2wwo).
i liked the article, because it's easy to understand for someone who hasn't done tigonometry since highschool :).

do you have any suggestions for reading material about matrix calculations?
brilliant
not even given it's hilarious names for common symbols? its requirement that you add a "please" to a certain percentage of lines lest the compiler complain about insufficient politeness?
not really, because people who actually _are_ superior tend to have less of a bee in their bonnet about it.
i think the whole point of the exercise was to allow silly categories. it's supposed to be a normal jeopardy game. time will tell i suppose.
why submit a question if you already can see the answer? 
i tried to get my dna code reviewed by a girl yesterday. she said "no." ;__;
wait, you consider rakudo to be "healthy"? it's damn near dead when compared with even the various experimental ruby or python implementations.
most of it is going to be unchanged.
sqlite is a much better alternative for small databases.
i had to tell my coworkers about this :)
remember: a fundamental misunderstanding by devs of how vectors work is how people playing goldeneye could run way faster than usual when strafe running plus running forward. 
the sony number was used in creation of the ecdsa signatures...

it's all explained at about 6:00 in [this video](http://www.youtube.com/watch?v=84wi-jsgnmq).


reflection is probably not covered but can be insanely useful (simply because it's not expected to be used).
funny that you make a big deal out of it.

does it mean you might like haskell which also uses &amp;&amp; and || ? :-)
[khan academy](http://www.khanacademy.org/) has a playlist on linear algebra, which seems to provide a good introduction to math and calculations involving vectors and matrices.
[matrix](http://en.wikipedia.org/wiki/matrix_(mathematics\)) on wikipedia for the basics, and then read [this](http://www.fastgraph.com/makegames/3drotation/) for how you use them in game graphics.

in simple terms: a matrix is a bag of numbers that describe a transformation in 3 dimensional space. this includes position, rotation and scale. you can then translate 3d points in space with that transformation, instead of doing it all by hand using sin and cos.

i could for example have a vector (0,0) pointing at (1,0). if i want to rotate it, i have to calculate the direction and length of the vector, change the direction and then move that point back again. with matrices, i just take the matrix of the object, multiply it with a rotation matrix and i don't have to worry what the previous result was, it just works.

it might seem daunting, but it makes calculating positions in 3d space a lot easier when you get the hang of it. most 3d libraries provide functions that will automate the creation of rotation or translation matrices (so you don't even need to know the inner workings), and when you get a hang of the concept you will appreciate it :).

example:

i have a object to which i would 'attach' another object.

i could describe the position from the 0 point in the world in matrix parent, and describe the relative position to that object in the matrix child.

i could then position, rotate and scale that object however i want, multiplying it with the child matrix will always position, scale and rotate that object in the correct position relative to the parent.


no. the human genome has been openly available since the human genome project was completed in 2001, and from the beginning, everything that had been sequenced so far was released as it progressed. still gene patents were allowed. 

it should be mentioned that it is not obvious where the genes are, given the genome. scientists actually used some time to find where all the genes were located. still, if there is anything that can be called prior art, genes should fit in that category. they have been around for a while after all.

another thing worth mentioning, is that he did not release his genes, but so called snp data, which basicly is where his genes differ from other humans. even though sequencing have been far cheaper lately, it is still to expensive for most humans, it has been done, and mike watson was one of the first, but this guy did not.
never a mischromeunication.
just to clarify, chronon *does* allow full object graph navigation.
however for classes that are not recorded, like the jdk classes we will only show the type name.
for all the classes that are recorded, you can browse and query the entire graph.

and yes, we will improve this functionality in the future so you will be able to see full graphs of all the classes in the system
there is a lot of misconception going around when it comes to patenting genes.

currently you cannot patent a gene per se, but you can patent a *use* of a gene, and that use has to be non-obvious (i.e. you can't patent it's normal function).

if someone finds that you can use gene x to perform function y, and that has never been described before, then you can get a patent on doing y with gene x.  this is no different from patenting a piece of wood (a natural object) that you have shaped to perform a novel function.

so... nobody has patents on *your* genes doing what they do normally.
(the article's comments don't agree with the "delta" figures in the tiobe index it links to.)
&gt; "map" is embarrassingly parallel. it's trivial to parallelize in any language.

well, that's what i said, right?

my point is that people normally don't even use parallel data structures and algorithms when it is absolutely trivial and obvious, because most languages require extensive changes to the code to convert a sequential algorithm to a parallel one.
filtering would be easy enough, but the more dimensions there are, the smaller the fraction of hyper-volume in the initial hyper-cuboid that is bounded by the hyper-ellipsoid (i think i got that right).  
provided that you keep the dimensionality low enough, it shouldn't be a problem.
citation?
sounds like legacy cobol.
[linked video skipped to 6:50](http://www.youtube.com/watch?v=84wi-jsgnmq#t=6m50s). watch until about 10m.
fwiw, that's called a bloom filter. i used them for decades before i knew what they were called. it's an awesome technique.
ok cool, thanks for that
* 23andme v1: ~580k snps, $999, 2006

* 23andme v2: ~580k snps, $399, 2008

* 23andme v3: ~950k snps, $260, 2010

super-rough math: doubling every 4 years, it will take 48 years to sequence a genome (3bn pairs) for cheap

note: calling this math "super-rough" is an understatement.
look up bloom filters on wikipedia.
my understanding implies they would be linear: you would download and update four times to go from 201 to 205.
surely they could have just had a unit vector, then scale for speed.
all of the business analysts at my last company were expected to learn sql within their first six months. even the chief operating officer wrote tons of reports using ad hoc sql. this wasn't a technology firm either, they were doing bond trading. 
but who invented checksums?  god thats who!
there's one on the musl site, though an impartial third-party comparison would be a lot more valuable.
4) natural language can be used to describe nearly any phenomenon. 

not sure about this one.  i think that the meta-language for any natural language is common experience.  people keep asking me "what is hang-gliding like?  is it like skiing?"  the answer is that it is like itself but that is not helpful.  i usually say that it is like being bed-ridden for months and then being able to walk, but that is not flying, the the disappointment that i did not try it earlier.


i don't think that you can describe a lot of things that are outside of common experience - you can't tell a child what an orgasm is like, nor can you explain to a teenager that it is better to be in your 50's, or explain to native americans that you want to buy their land.

and chomsky is great for seeing how many artificial languages work!
til there are programmers that don't understand elementary trigonometry.
nice plugin! do you plan to support recording remote debugging sessions ? i'm doing javaee development, where i attach the eclipse debugger to a remote server (glassfish). would be nice if i could record that, too.
could u send me the codes for the english parser plz?  thx
contrary to popular belief, identical twins do not have identical dnas.
the way remote debugging works is that you run your program with recording enabled on the 'remote' machine, then transfer the recording to your local computer to debug.

we will have integration with eclipse in the future to make this easier, however if there is nothing stopping you from doing this right now.
i don't care. i feel like i've been lied to 8 times, and now, on the 9th attempt, microsoft is saying, "no no, this time, i'm for real. trust me."
aside from binary size on disk, bloat is often a bigger problem for dynamic-linked binaries. the entire size (including sharable disk-backed code and rodata as well as data, heap, and stack) of a small static linked program is often smaller than just the non-sharable part of a dynamic-linked program, especially if the latter uses a lot of libraries. the real benefit of dynamic linking is not memory but the ability to upgrade library code without rebuilding programs. once musl has native dynamic linking support, it will strive to make dynamic linking almost as fast and bloat-free as static linking.
ahh, good ol' djgpp+allegro.  i almost wrote a mmorpg in that, but i could never find internet socket code for it so i couldn't finish it.
this is why i should have known better than to add /r/programming to my front page. even after following your link, i still have no idea what's going on. that's what i get for leaving the programming world for 20 years.
thank you for the clarification. lack of collection examination seems to be the biggest drawback right now.
to allow upgrade via a diff. see the article.
&gt; the entire size (including sharable disk-backed code and rodata as well as data, heap, and stack) of a small static linked program is often smaller than just the non-sharable part of a dynamic-linked program, especially if the latter uses a lot of libraries. 

what are you even
quoting yourself right up top. classy.
if your program does any geometry, use vector calculus. you'll find it's much simpler and much faster. there's rarely an excuse to do trigonometry.
it was already [forked](http://www.reddit.com/r/funny/comments/fkixv/guy_uploads_his_genome_to_github_another_forks_it/) :)
i hope lisp. (scheme, cl, not clojure)
name is relevant.
yes, we knew that will be the biggest issue for this release.
however if you are using that collection in a loop, say adding values to it, just click on the loop variable and you will be able to see all the values of that variable in the variable history view, thus showing you what was added to the collection.

you can also step back in your code to see what was added to the collection.

look at the video on 'recorded console' in the 'chronon in action' section which shows how to debug an issue with a collection type.
assembly text is not as dense as pure binary, and sending assembly diffs to update would take more bandwidth than sending binary diffs.
who said that it was not important for web ventures to be profitable? i said that when you are measuring the scale of an operation, you do not do it on the basis of profitability. airlines are routinely money losers but they are serious large scale operations. gm did not become an irrelevant small business when it became unprofitable.

do you understand that we are talking about operations and not on whether we should add these companies to our retirement funds?

in any case, this is all ridiculously silly given that you have been told several times that the company in question is profitable.
indeed.  you still haven't refuted anything i've said, or even argued with any of my points, only saying that as a whole, i'm on the "ignorant side" of the argument.  you've said that poor encryption is worse than having no encryption, i've pointed out that a breakable layer of security won't deter intentional thieves, but it will deter general miscreants from becoming thieves.  how or why is that wrong?  do you have any research or justification for saying so?
did you happen to read the article?
i hear the same rubbish about c and ada from java and .net developers. guess who writes a lot of the really advanced infrastructure software like aerospace systems? it ain't the java and c# code monkeys...

you'd do well to learn that programming is not a popularity contest.
you seem to have some sort of agenda to judge me just because you don't like my attitude.  generalize all you want, it really doesnt make much of a difference.

i could just as easily try to imply that given how defensive you appear to be that you obviously are the type of person that i'm complaining about.  that is just ad hominem at the end of the day though, and not the way to make an argument.

if you have nothing better to do though than attack me, i think i'm done here.
i'm going to go against the common sentiment here and say 'no'. rather, in a *general sense* being aware that these sorts of problems can exist is very important. not all pieces of code or programming-related tasks are the same, and attempting to compare the complexity of two things based on technologies in use is a quick way to end up with serious problems. it's like saying that a ferrari should be able to pull a boat because a ford super duty can and they're both v8's.

what you probably *should* look at, if you're looking to spend time boning up on this sort of thing, is:

* decide now if you want to be a developer or a business admin with a lot of technical knowledge.

* learn enough sql to be able to write most of the queries you'll need. this includes understanding the basics, having a decent grasp on how joins work, and enough knowledge of everything else to look it up when you need it.

* learn to use excel really, really well. you probably cannot know enough about excel.

* learn some statistics, and how to use a statistical computing system. (for example, [r](http://www.r-project.org/) )

* pick up a scripting language for general programming. this is useful to help you do light data massaging and pull data from one thing to shove it into another. since you'll primarily be on windows machines, this probably means visual basic script simply because it's similar enough to visual basic for applications that you can use the knowledge for excel macros. if you're really dedicated, also learn [python](http://www.python.org). it has pretty fantastic libraries that get you 80% of the way into accomplishing a wide range of tasks. in either case focus on general understanding and getting things done rather than *knowing* all of something.

try to remember to keep it all in context. any time you spend learning about technology and programming could be spent on learning economics, management skills, or a whole host of other topics. i don't mean to discourage you, i'm actually really happy you're interested, but you won't be helping yourself or really anyone else if you go overboard and become half a database administrator. unless you want to be one, then make sure you go all the way.
yes, they seem to be doing intelligent binary diffs.

you say google should abandon compilation to binary form and replace chrome downloads with chrome assembly text downloads?
v'z cerggl fher, vs fbzrbar guebhtu gur rssbeg gb rira nggrzcg gb trg gur cnffjbeq, v guvax gurl jbhyq chg n yvggyr zber rssbeg gb qrpbqr vg.
if it's [good enough for google adwords](http://en.wikipedia.org/wiki/adwords#technology), it's good enough for me.
deep blue was too. just give it minimax and some tables, and you win
it is good if data access is easy.

if performance is an issue, then easy includes understanding that too.

i think the nature of sql makes performance issues harder to understand.


was there an actual example link somewhere on that page that i didn't see?
the problem here (and with similar articles) is the validity of the tiobe index. look how it is calculated (excerpt from the tiobe website):

---

"the ratings are calculated by counting hits of the most popular search engines. the search query that is used is

    +"&lt;language&gt; programming"

[...]

based on these criteria currently google (33%), youtube (10%), yahoo! (3%), bing (0%, too many false positives still), wikipedia (17%), blogger (33%) and baidu (3%) are used as search engines.

the number of hits determine the ratings of a language."

---

in other words:

the ranking is based on the number of google (ect) results for "&lt;language&gt; programming". so it's a bit difficult to see accept the validity of the index. 

the tendency of the index may be right, but in the end it's more a "internet hype measure" than a measurement for "success".

nope. they're doing diffs of the disassembled code -- assembly code with the symbols restored.
best example i've seen for interfaces is this (i use c# but makes sense in java too)

    list&lt;ivehicle&gt; vehicles = new list&lt;ivehicle&gt;();
    vehicles.add(new truck);
    vehicles.add(new car);
    vehicles.add(new bus);

if truck,car, and bus inherit from the interface ivehicle they all are required (or compiler will not compile) to have publicly accessible methods and variables defined in the interface. it also lets you do multiple inheriting in c# (not sure about java) i could make a class called schoolbus that inherits from bus but also from the interface itransporter.
reading [wikipedia paints a different, (likely biased) picture](http://en.wikipedia.org/wiki/full_genome_sequencing#race_to_commercialization). i assume the narrative is a mess because of competing financial interests fighting over the content. obviously many people are projecting / planning for cheap sequencing, because it's in their best interest to be optimistic, but even the picture advertised prices paints shows the price going from 40k to 30k to 20k to 10k. 

even a linear picture suggests we're closer than 48 years. your data points do as well; it suggests doubling every two years or faster. price halved from 2006-&gt;2008, and price nearly halved and snps doubled in 2008-&gt;2010. 

it's possible the technology 23&amp;me is pursuing fits their objectives of selling analysis, rather than working towards full genome sequencing. how would they test for snps they don't know exist, and what would they say? i assume they plan to take it up when it's more profitable than their existing system and no sooner, and other companies will eventually carry the torch to their doorstep. the greater challenge by far is medical research keeping up with the pace of data. 

i certainly don't want anyone to invest or ignore medical advice based on my analysis, but i remain unconvinced by your admitted "super rough math". perhaps we'll split the difference and call it 10 year's time ;) 
&gt; now let's do it in fixed point because it's totally worth the pain vs speed ratio

also this.
oh god so much of our old codebase did that.  and then they pulled values out of an arrayref instead of by column name. what could go wrong.
how this atrocity got through moderation i'll never know..

    //use split with implode to fetch array values or elements
    list($ip, $line, $filename) = split(',', implode(',', array('100.1.2.3','23','/index.php'))); 
    echo $ip.$line.$filename; 


result : 

    100.1.2.3 
    23 
    /index.php
i just don't know a whole lot of programmers developing games in c++ who haven't yet passed middle school math.
w-what the...
right, and why should they distribute assembly text instead of binary?
python is definitely hyped. possibly for good reason. (insert flamewar here)

and haskellers just hoogle. ;) lotsa hype going around haskell/erlang due to the "learn you a/some __" websites. also possibly for good reason. (insert another flamewar here)
awesome.
&gt; we can ship a ton of code without a heavyweight qa process. if something goes wrong...

how do you know if something's gone wrong without qa? i imagine you have automated end to end tests?
problem is teaching people good habits form the get go. i started programming with php and javascript and as most php developers had horrible programming habits for a long time. i started playing around with ruby and then cakephp and i could not even grasp what could have been better about my code until i understood how mvc worked. now i'm doing some c# development and the constrains and rules are a blessing, because i understand why they exist.
yes, i'm just saying it is not an incremental update, it's a full re-install, even if their are incremental actual changes.
&gt; what the fuck are you talking about?

we're discussing the change in c++0x that makes certain operations (including common ones like `std::vector::push_back`) use the move-constructor if available; and furthermore the implicit definition of move-constructors on some types.  this change makes previously correct c++ code no longer correct.

&gt; compatibility is one of the things that those creating the c++ specs, as we as the most important implementations, take very seriously.

they're supposed to take it seriously, which is why the compatibility-breaking implicit move-constructors are so distressing.  ideally the new c++ will not break compatibility, but if it does we better get something awesome in return.  at the moment it looks like we'll get the worst of both worlds: broken compatibility for a tepid new feature.

my comment was snarky (apologies for that, i was sitting frustrated in a doctor's waiting room) but it nevertheless had a kernel of truth: if you define a class, there's a good chance that it may acquire an implicit move constructor and if it does, there's a good chance it will break under c++0x.  if you want your code to be c++0x safe, you really will have to vet it and possibly react.

&gt; besides, them using the new features within their standard libraries has absolutely no impact on anyone using those libraries. it's an internal implementation detail hidden by the standard library's api. 

it would be nice if this were true.  this is the "maintain compatibility" stance.  unfortunately that is not the current status.  i'll summarize the issue, in case you're unfamiliar with it.

some operations need to logically "move" an object, for example, `std::vector::push_back` may require growing its block of memory, which means all the current objects must be moved to the new block.   today this is done by allocating new memory, copying the old objects into it, and then deleting the old objects.

copying an object invokes the copy constructor, which usually triggers copying the object's own contents.  for example, a `std::string` typically stores a separately allocated array of char, and if you copy a `std::string` it may have to copy that array.

once the copy is done, the old objects are immediately deleted, so copying that contents array is a big waste!  it would have better if the original, condemned string could have just moved its array to its clone before it dies.  c++0x formalizes this with the "move constructor," which means that while the objects themselves must be copied, their contents may be moved efficiently.

if they stopped there, you'd be entirely right: the stl classes could just use the move constructor when defined, and fall back to the copy constructor otherwise, and there would be no compatibility risk.  the end.

but then again…wouldn't it be great if the language could just define these move constructors for you, like it does for copy constructors?  then your code would just automatically get faster when recompiled!

and indeed it would, but then any code that expected the copy constructor to be called will be broken.  ok, can we make it only define the move constructor if there's no copy constructor?  sure, but then this other thing breaks, etc.  the committee's current stance is to iterate until they find a "balance" between the amount of code that breaks and the usefulness of the implicit move constructor.  both are expected to be nonzero.

**tl;dr**: c++0x will sometimes implicitly define and then call a new function on your class that does unexpected things like gut your instance variables.  that breaks what is currently safe and reasonable c++.  the committee seems ok with that.
this guy went on to work for jagex, creators of runescape. not sure if he still does work for them, but he wrote a very interesting homebrew audio engine.
just wondering, is there an equivalent to this for c, python, haskell, or obj-c? or is this truly a game changer?
that's right, no one on reddit ever talks about perl.
i don't think your math will hold in this case because a completely different technology will be used to sequence the genome than the one that is used to capture/identify snps.

right now they're using microarrays to get the snp info. the $1k genome will be a esult of the "next generation sequencing" technologies that are in use, or being developed, now.

could you please read the article?
a few (obvious) notes, but in case anyone is wondering:

first of all, the output is wrong, it would actually output:

`100.1.2.323/index.php` (ie. no new lines)

but secondly, the split and implode are entirely useless as you don't need to use this function to assign an array to variables using `list()`, eg:

`list( $ip, $line, $filename) = array('100.1.2.3','23','/index.php');`

thirdly, there's probably no good reason why you would have an array containing completely different items such as this - so it's a silly example anyway.

and also you can simply do, with a given `$array`:

`$ip = $array[0]` etc.

oh, some more problems with this:

should be using `explode()` instead of `split()` as there's no point leveraging regex to find a comma.

and if the array had any elements with commas in it.. then lol!

also, if `admin at ejaz dot com` is his real email address.. well it looks like he might have accidentally let his domain expire. whoops.
skew too. [wikipedia has a list](http://en.wikipedia.org/wiki/linear_map#examples_of_linear_transformation_matrices).
&gt;you seem to have some sort of agenda to judge me just because you don't like my attitude.

that's more or less true, but then, you seem to have some sort of agenda to judge everyone in your company because you don't like their attitude.
it's one thing to do it on paper, and another to apply it to actual 2d/3d data. people may learn the formulas but, being unable to express what they _mean_, they're quickly forgotten.
because if you have to ask for an implicit move constructor, it's not an implicit move contructor, it's an explicit move constructor.

the c++ standards body wants move constructors to be usable by existing code without changing anything. this allows compiler vendors to say "use acme compiler 2011 and your code will magically get faster, sometimes asymptotically so."
i'll help you if you tell me what your interface is supposed to do? what is int "i"? what am i removing from what? etc.

if it's not a popularity contest then why do we have the ability to upvote/downvote? on sites like reddit, programming is a popularity contest.
actually, its the other way around.

perl was the de facto standard for cgi scripts/web applications.

but it was terrible at it, so php was designed to be perl-like, but with better support for web apps.

also the links broken, so if you were trying to link to a joke or something, none of us got it.
nonetheless it's the classic esoteric programming language. there wouldn't be a point in having a special joke languages list in an esoteric languages wiki if intercal were in it. you'ld have to consider all of them joke languages then.
are you criminally ignorant, or are you only *pretending* to be criminally ignorant for the laughs?
&gt; on cost, you can't beat free.

   * and microsoft can't meet the portability that many people want either.
   * and microsoft's position on open source is pretty much the opposite of where most young developers are today

&gt; only if you completely ignore microsoft research, f#, parallel programming work being done in the .net platform entirely, microsoft surface, and a slew of other projects.

i've been using microsoft products for 20 years now, and have found microsoft to be the single biggest stifler in the industry.  parallel programming &amp; sql server?  please, i was running parallel databases on informix 16 years ago, and it was available on teradata 20 years ago.  so that's about how far behind the curve they are.

&gt; i will tell you that you are talking to someone who is very enthusiastic and very happy to be working with microsoft's platform and particularly with microsoft's development tools.

i completely appreciate that - i've often found myself having a great time with unpopular technology.  but i think it's also important to acknowledge the affect of where the industry is headed.
he's describing an algorithm finding the intersection of a set of inverted lists of trigraphes. [bloom filter](http://en.wikipedia.org/wiki/bloom_filter) is a different animal.
[i just use links (a console/text mode browser).](http://i.imgur.com/y9zz6.png)

i've found that coworkers don't even look at it - they seem to go: "oh, loads of text in a terminal; must be code or something...".
it's not a game theory problem. the whole jeopardy thing is a gimmick. the interesting part is the natural language processing.
"unable to express what they mean"

and that's what's wrong with math education. they teach manipulation of symbols, not math.
i fixed the link.
i'm running ubuntu, which makes me feel worse.

but in my defense i triple boot unbunt/win7/osx and don't pay attention to my os when surfing reddit.
[another fun one.](http://us3.php.net/manual/en/function.require.php#101670)
it's harder to create centralized dbs with sqlite and arguable mysql is better for web apps.

i dunno, i work for a university it department, and there's a mysql server with a bunch of small dbs on it, and doing it that way seems to be better than having a bunch of sqlite files running around, but often times, yes, sqlite will be a much better solution.
sorry, i know this is old, but:

&gt; the arduino is mostly based in **italy**,

stopped reading here, closed the article and started laughing. i'm italian and i can affirm that italians that remain in italy can only make pizzas and nothing more than that. something this complex, *made by italians*‽ come on, this must be a joke, they copied japaneses like with the frecciarossa train, right?
it is true that nl cannot describe the taste of a strawberry, the thrill of your first baby being born, flying in a wing suit, or a lot of things. but those are experiences and they must be witnessed by someone to be appreciated. even if i could describe a red sky to a blind person, s/he would never understand until that person had seen it him/herself.
chill out.
&gt;thirdly, there's probably no good reason why you would have an array containing completely different items such as this - so it's a silly example anyway.

people sometimes do the equivalent thing in python, with tuple literals, as a way to quickly assign multiple variables in one line; e.g.:

    ip, line, filename = '100.1.2.3', '23', '/index.php'

instead of:

    ip = '100.1.2.3'
    line = '23'
    filename = '/index.php'

but i guess it looks sort of silly with php's heavier-weight syntax.
i felt like it was 1996 all over again
ex pe rt sex change is the best web site.
uh... how exactly would you replace trig with vector calc? that doesn't make sense to me... it's like replacing a trowel with a weed whacker.
it is... but this is far more general than physics. 
thank you op.

i was actually struggling with this when i was attempting to create my first game, which i subsequently gave up.
there is now a reason to return to it.
anyway aahh
i think i would be cool with it it there were a way to actually mark the interfaces with that information in a way the compiler could at least half-way understand. just having it in the documentation is asking for trouble.

this is why the whole "design by contract" thing is so interesting to me. it isn't just about saying "x must be &gt;=0", it is the long term prospect of actually encoding usage semantics in the code.

well, a markup language is a bit different than an iterative programming language.

there's nothing wrong with vb, or vb.net.  they are the most widely used programming languages in the world, and there's good reason for it.

the reason vb is used for introduction classes is likely because it's not case sensitive.  you don't want a first year student spending hours on a typing error.
well you guys seem to have turned out just fine.
i don't know about exact comparisons with chronon, but i believe gdb 7.0 can do backwards debugging. ocaml has actually had this facility for years iirc, although i think you had to use the bytecode compiler to use it.
christopher monsanto (http://en.wikipedia.org/wiki/user:christopher_monsanto) has been tagging and deleting numerous programming language articles on wikipedia due to a supposed lack of notability.

nemerle and alice ml have already been deleted. factor, joy, ioke, pure, and others have been tagged. yet others, e.g. arc, surprisingly haven't been.

if you have evidence that can help stop dozens of programming languages from being deleted from wikipedia, please go post the relevant notability information on the appropriate pages.

(or, better yet, figure out how to get wikipedia to adopt a policy that makes more sense in the context of programming languages. a vast number of extremely valuable pages will be deleted if the notability requirements are strictly followed. languages grown outside academia, e.g. clojure and io, seem particularly vulnerable due to a lack of journal publications.)

**edit:** please do not blame wikipedia itself for this. after all, one should [ignore all rules](http://en.wikipedia.org/wiki/wikipedia:ignore_all_rules) when it helps improve things. unfortunately, christopher monsanto is only concerned with the letter of the law with respect to notability while failing to actually improve anything. there is no objective standard by which removing nemerle helps wikipedia and the content should be replaced.

**edit:** christopher has now promised to [stop nominating articles for deletion](http://en.wikipedia.org/w/index.php?title=user:christopher_monsanto&amp;oldid=413834663). however, there is still damage to undo. please continue adding notability information where appropriate and restore any pages that were inappropriately removed.
can this revert eventual changes on external files? i hope so, otherwise how can it be "time-travelling"*‽*
i have always found parallel programming to be trivial. once you have a thread-safe input and output queue for mutable data the rest is no different than writing single-threaded code.

concurrent programming, especially where user interfaces are concerned, is a bitch. but that is because of the constraints of our gui toolkits more than anything else.
looks a bit like proguard but i could be wrong...  it's the one i use...
* [case](http://dockets.justia.com/docket/massachusetts/madce/1:2009cv11813/125212/)
* [article](http://www.h-online.com/open/news/item/patent-action-over-google-s-courgette-845028.html)
* [lwn article](http://lwn.net/articles/359939/)

seems like it's not resolved yet.
mainly because i used to program a lot of games when i was kid, not formal 0- 18 year old education.
hey, thats what math is.

what you mean is "doing calculations"
start here http://en.wikipedia.org/wiki/euclidean_vector
don't use mysql if you want a real database.  don't cite "facebook uses it" or some other nonsense, mysql's feature set is garbage.  their heavy usage of memcache is telling of how bad the mysql performance is for read loads.

my bets they could use a real database (postgres if you want floss), give it a ton of memory instead of using memcache servers, optimize their indexes, and you could get a system that eats up their mysql/memcache system for lunch (select statements are fast if their table is in memory and properly indexed).
s/\\.$/ poorly./
&gt; or, better yet, figure out how to get wikipedia to adopt a policy that makes more sense in the context of programming languages.

anything at all, not only programming languages. 

&gt; *[what is wikipedia?](http://en.wikipedia.org/wiki/wikipedia:faq/overview)*

&gt; wikipedia is an online free-content encyclopedia that anyone can edit and contribute to. wikipedia co-founder jimmy wales has described wikipedia as "an effort to create and distribute a multilingual free encyclopedia of the highest quality to every single person on the planet in his or her own language." wikipedia exists to bring knowledge to everyone who seeks it.

this was accurate 10 years ago, when no one understood what a wiki was. today, it should move on and accept that it's an insult to wikipedia to call it an encyclopedia.

**wikipedia is wikipedia.**
&gt; there are 2 * pi radians in a circle, pi being a mathematical constant of roughly 3.1415927. so there are roughly 6.282 radians in a circle. why do they make things so difficult, you may ask? well, that is all figured out by mathematicians, and mathematicians are a mysterious kind of people.

oh, for fuck's sake.

&gt; actually the reason for introducing radians is as follows. the length of the circumference of a unit circle (a circle of radius 1) is exactly 2 * pi. that means that the length of the circumference is exactly equal to the number of radians in a full circle. do we gain any advantage by this knowledge? no, but mathematicians think it is cool.

seriously?  okay, here's what we gain from knowing this.  if your circle's radius is 1, the length of the arc described by an angle and the angle's size in radians *are exactly the same thing*.  this is useful if you need to convert radius and change in angle per unit time into velocity, to pick just one of the many things a game programmer might use this information for.

**edit**

of course, if you measure angles using an eight-bit system and discard anything over 255, you're going to run into some interesting other problems if you try to calculate velocity from an angle.
neither of those. calculations can be automated.

math is human made abstractions, symbols simply try to describe those abstractions.

you can learn to manipulate symbols by being well drilled, you don't actually know what the abstractions are doing, you just know to move that symbol over there for this particular problem. this leads to extreme lack originality in math, and when they come to actually synthesizing solutions for problems they never trained for they become stuck.

it's akin to knowing what words in the english language look like such as 'hello', but don't understand the meaning of 'hello'. thus can't compose original sentences, other than being given pre composed sentences to manipulate.

albeit i'm no mega genius at math, i can understand fourier transforms but not much higher since i've never needed it. i'm just recounting my earlier experiences of passing math exams, compared to true understanding you gain from playing with math, especially through programming experience.
 fyi, one of the most useful and quick algorithms (sorry forget the source) i've used for estimating 2d distance between two objects (ie. a squared + b squared = c squared) is to take the larger side and add 1/4 the shorter side, this is really fast in machine code and is close enough to get a distance on a simple side scroller or whatever. 
source?
oh wow.

*it's not encryption, but it's powerful security, quick and cheap, for custom-built databases.*
yeah, i don't know of any modern systems where fixed point is faster. i'd save fixed point for calculating the national debt in pennies.
what an arrogant nong he is:

&gt; the problem is that nobody checks these articles except those who have an intimate connection with the language, and understandably these people want the article to stay.

well, yeah. somebody somewhere is interested in these languages, doesn't that constitute notability?

&gt; we need better criteria for establishing notability of programming languages: for some reason, a number of people seem to think languages are notable if they are mentioned in a book/third-tier academic paper or have a few people who contribute to/use them.

we need better criteria for establishing notability of star wars characters. for some reason, a number of people seem to think these characters are notable if they are mentioned in a book/third-tier spinoff game or have a few people who contribute to/use them.

&gt; this is not the case. covering these languages on wikipedia makes it harder to find *interesting* programming languages!

we have this thing now, you may have heard of it. "google". 
the funny thing with tiobe: if i write a blog-post which contains the text "programming in java is awful, i will never do it!" or "haskell programming totally sucks!" this would count as "success" for java or haskell because those posts show up in search results for java or haskell.

i took an opengl class during my undergrad and played around with a lot of that.  the end results were always awesome, i made a lot of cool looking sample programs -- but i just hated how mathy it was, even by using matrices and vectors.  it just wasn't my bag, but it made me gather much more respect for graphic coders.
it's 1/2 the smaller, i always heard.
&gt; today, it should move on and accept that it's an insult to wikipedia to call it an encyclopedia.

when i see this kind of deletion craziness, i start to think it's an insult to encyclopedias to call wikipedia one.
i would have paid a fuckton more attention in trigonometry (let alone linear algebra) if i'd had any idea of what i could really use it for.
yes. i don't think schools more advanced than that really use silly mnemonics like "soh cah toa". [wikipedia at least indicates that trig is usually taught in middle schools](http://en.wikipedia.org/wiki/trig).
its not their attitude, its a combination of their pay, their lack of skills core to their job, and a complete willingness to make that my problem :p

there was one guy that was a complete ass.  i didn't like him as a person, but at least he did his job.
yeah, that's a good point. i went the engineering route so it's second nature to me, but i forget that most people see math as simply hoops to jump through before they can pursue careers in waiting tables and getting pregnant.
can i improve it and recompile myself, then?
unfortunately public school teachers for the most part are pretty much the least qualified people to teach anything useful.
pfft amateurs

i just open up my frontpage files in word and tab the text so far to the right that the hackers can't see it

takes a while but at least you know you've done the job right
clojure's got some books, fanatics and it's the current big thing (ugh), don't know about io. i can't help, though, as i'm not familiar with any of those languages.
my brain hurts. i just want to rip that guy's head off.
holy shit, he linked to the (defunct) cult of kefka website. i used to get all my roms from there.
i prefer triggernometry.
why not clojure? 
this is very informative.
thanks.  great response and well-researched.  since it was an actual case filing, i assume it would be on the internet somewhere if it had been resolved, but it mind end up being a quiet resolution.
your going to have trouble managing squat with that sort of facial hair.
i agree, it's the style c code ought to be written.

the portability bullshit on the beginning of pipe.c should be in a different source file/header, though.
sure, like i said though, you should be able to run multiple queries in parallel and concatenate the results. for an ellipse, your initial box could be drawn large enough that all but 4 sections (one on each edge) would be covered, and then a second set of queries could hit all of those smaller sections.

might be more efficient to split the query up like that just because you'd end up with at least one dense volume (covering the interior of the n-ellipsoid) and a number of sparse peripheral volumes that would scale linearly with the number of dimensions. for a square, you would have 4, for a cube 6, for a hypercube or n-cube, 2n additional volumes. 
u mad bro?
it's not the graph paper it's the fact that it's a different piece of paper duh.
designating the elements within a matrix requires some trig to set up, no? 

or is that what you refer to by "3d libraries": if so, *somebody* is doing the trig under the covers for you.
&gt; name is relevant.


not really. name aside, it's a fair point.
oh i know... but it's still "incremental" in the sense that most of it is unchanged. apple says they use full disk images to ensure that there are less problems updating. i find this kind of crappy, though. you could download a disk image once and then update that :/
because of [this](http://www.reddit.com/r/programming/comments/filsf/what_programming_language_to_learn_next/c1g98y2).
i'm familiar with what a euclidean vector is. now, if i have a ship that i can rotate left and right with my arrow keys, how do you propose i figure out what the cartesian components of the velocity vectors of the bullets it shoots are without using trigonometry?
&gt; i went the engineering route so it's second nature to me

basic trig should even predate that, no?

&gt; careers in ... getting pregnant

so, you've met my ex-wife?
&gt; and microsoft can't meet the portability that many people want either.
&gt; and microsoft's position on open source is pretty much the opposite of where most young developers are today

surely.  but that's just my point.  there are a number of reasons that people choose not to use windows on certain projects that have nothing to do with your argument that windows developers are less astute.  you've just listed more of them.

not aiming for portability when it's not the goal of your project doesn't make someone less competent.

not strictly adhering to certain political beliefs and philosophies on open source don't make a person less competent either. 

&gt;please, i was running parallel databases on informix 16 years ago, and it was available on teradata 20 years ago. so that's about how far behind the curve they are.

sql server has had multi-processor and multicore capabilities for a long time.  i'm talking about c# 5.0.  i'm talking about f# workflows.  and no, i'm not saying that a lot of those ideas haven't been available elsewhere in different incarnations.  but their implementations in these two languages are in some ways new approaches and are features that were not formerly available in a mainstream oo/hybrid languages.

&gt;i completely appreciate that - i've often found myself having a great time with unpopular technology. but i think it's also important to acknowledge the affect of where the industry is headed.

again, i'll agree, microsoft has done a lot of damage to the industry as a whole (particularly in the past.)   but, again, that has nothing to do with the competence of those who choose to use their technology.
skew (as well as non-uniform scaling which generates skewing in children) can add complexity in a lot of areas (shading, for one), so it should be avoided whenever possible.
djgpp is just (gnu) c++ (i.e. a gcc port), isn't it? it's 32-bit, isn't it?  (i really don't know -- that's just what i understood it to be)

wasn't there a posix-ey interface to the windows socket (tcp/ip) stack that you could use? or were you trying to do something fancy w/ udp multicast or rdp?
and makes his code incompatible to vc++. microsoft supports c89 only afaik.
*only* if google is your referrer. if you come in any other way, it's just the sales pitch, no answers.
this is relevant to my intrests

[there is also the perverse.](http://us3.php.net/manual/en/control-structures.if.php#90073)
thanks so much, this confirms a ton of stuff i was forced to figure out myself for lack of a good resource!
i couldn't find one that i liked and had some free time so i [made my own](https://github.com/andrewmcc/igreddit).  current features are:

* ability to add your own subreddits
* optional translation of imgur links to either filmot or mirur

i'm currently debating whether or not to use the reddit api to pull in existing subreddit subscriptions.  would you give a 3rd party app your login details?  not sure...

anyway, comments/suggestions welcome... =)


while i haven't really programmed in io since 2003, the only programming book i've bought in many years has a chapter on it.

i do fail to understand why we want to convert the tool that's supposed to represent the accumulation of human knowledge into an intellectual patent system where those who find something uninteresting enough can decide to just not include things because the reviewers are in different circles that don't care about people's efforts to actually increase the states of their respective arts.
maybe you should repost this to r/compsci and also lambda-the-ultimate.org. i know nemerle is noteworthy for its metaprogramming facilities, but i'm sure each language is noteworthy in its own way, most languages are in fact noteworty because hardly anyone writes a language without intending to bring something to cs field as languages compilers are notoriously hard software to write.
professionals use vim.

you amateur.
wikipedia isn't running out of space. anything that's more interesting than a user page should stay.
what a nazi...
neat. for maximum funniness you might want to try a `continue` inside your enhanced `if`.
i just shit my pants.
yeah, i think there is a lot of research in that. sadly c++ for instance lacks the requisite type info.
god what a fucking dipshit.
they certainly have enough room for pokemon, star wars &amp; other types of trivialities, i can't see why programming languages, maths/cs articles, philosophy &amp; the like have to go. if i had the space &amp; the time, i'd love to fork wikipedia &amp; take a more inclusive approach. 
am i the only person who tried the commands given, assuming they'd do something interesting?
just saw this, did you ever end up doing this? i'd love to see it
really, programmers?  really?

this is simple shit.
really?  go look up nemerle in your brittanica set and let me know how that works out for you.
thanks, i have no idea how to do that. lol
they also killed the qvwm article -_-
i think you should try linear algebra done wrong:

www.math.brown.edu/~treil/papers/ladw/

download the pdf from that page- it's a great book. maybe more than you're interested in learning, though, so you'll have to do some skimming.
oh gosh, that's exactly what some ex-colleague did in his code all the time. never would've thought there was another a single soul on this planet who would consider this somehow "useful". btw, he called his coding "style" oldschool.
what's with the silly title to this otherwise interesting post?
[this trick is mentioned by the actual php manual in the documentation for do/while.](http://us3.php.net/manual/en/control-structures.do.while.php)
shout out to xkcd?
http://xkcd.com/221/
thanks for that hint. a pity they didn't release it for linux (which i'm using), but my client will be happy as they use windows and vs.
djgpp....what is this 1996?
yeah, i never really understood the point of the notability thing. it's completely counterproductive to start a project with the goal of cataloging and maintaining all human knowledge and then deleting anything that you're nearly the only source of. "all right guys, how many times do we have to say this? we only want stuff that is available in 100,000 other places. geez."
yeah let me get this straight. they're reinventing the wheel is order to hopefully save a little weight over glibc? sounds like a pointless project imo.
vg
200&gt;
cool and secure - hight five!
i contributed to a zelda-like 2d overhead adventure game where i had to calculate the angle at which the mushroom canons should fire in order to hit the player, assuming the player maintained a constant direction and velocity.  (not like the homing missile, which can make constant corrections based on current location of target.)

i had a hard time finding a solution online to this "interception problem."  is this the kind of thing that shows up in a introductory textbook which i never read?  or maybe the kind of thing that's so easy it doesn't need to be documented?  or maybe i'm just using the wrong search terms?
visual studio 2010 does this for .net languages.

oh, my bad!

interesting, an arab it company hiring .net devs.. and in the job info it says:

"age: between 22 – 30" ... lol... i guess maybe that's not illegal in saudi arabia.
&gt; yet others, e.g. arc, surprisingly haven't been.

he probably reads hacker news.
they cant be serious...

"don't worry if you don't understand this right away or at all. you can code scripts and even powerful scripts without using this 'feature'. since php 5.3.0, it is possible to use goto  operator instead of this hack."
without researching this at all, the problem sounds like the goldeneye developers were just adding two vectors together (v1 + v2) but this results in a final vector that is √( length(v1)^2 + length(v2)^2 )* in length and so the characters run faster.

**this portion of the comment has been redacted due to extreme dumbness.**

*this is true because the run (v1) and strafe (v2) vectors are perpendicular to each other.
the [node.js article](http://en.wikipedia.org/wiki/node.js) was also deleted right away and there was no backup on [deletionpedia](http://deletionpedia.dbatley.com) available.

after i complained here the article was restored by some wikipedia admin.

i really hate deletionists. what's the point in making wikipedia *less* useful?

that same deletionist also deleted a dozen articles about japanese game composers. i really feel sorry for the guy who wrote them. must have taken him days to write all that stuff.
bah, monsanto's account should be suspended on account of vandalization. he hasn't consulted the opinions of others on this matter and thus acted alone for which there is no excuse. if anyone here is high in wikipedia hierarchy i should ask them to revert wikipedia to a prior state and possibly ensure that his actios get a public record somewhere in order to discourage similar behavior in the future.
the one under that is almost as spectacular. it's like they've never conceived of testing equality to false, but some how understand how to return false, and negate with !. wtf?!
make clean; make; make install
ಠ_ಠ
http://xkcd.com/224/
doesn't brittanica have roughly as many errors as wikipedia?
i would say that maintenance of perl programs is 50% a sick joke.  so at most this is 50% ignorant, but i would also say this errs on the side of justice at this point.  the uninitiated should be warned that they will come to dread maintaining perl code.

it's 2011, how exactly does perl 5 stack up these days?  in the best of lights.
well, one has to wonder *if* some of these languages are notable.

factor, **for example**, does have some fans, but is it *notable*? i personally know the creator of factor, and a few of the developers. factor is growing, but i wouldn't include it in an encyclopedia until it's something that is solid, stable, mature, and is rooted securely into a foundation that keeps it relevant.

i don't want to turn this into a flamewar about what is notable or not. it probably does no harm to have factor as an article, but it *is* true that wikipedia is being proliferated with all sorts of niche languages and things that have no real relevance to an encyclopedia.

edit: grammar, take 1
from my point of view that obscure stuff is wikipedia's raison d'être.

obscure facts and trivia. that's why i visit wikipedia. this is what makes wikipedia unique and useful.
this is funny
&gt;if you came here because someone asked you to, or you read a message on another website, please note that this is not a majority vote, but instead a discussion among wikipedia contributors. wikipedia has policies and guidelines regarding the encyclopedia's content, and consensus is gauged based on the merits of the arguments, not by counting votes

wait, not funny, sad.  yes, sad is what i meant to say.
yet reading through the comments, the consensus was to keep the page, not delete.  there was nothing of merit for deletion.

yeah that exactly the problem, my solution simply adds the vectors together, turns it into a unit vector then scales to correct top speed leaving a vector in the right direction, at the right speed. 
i think the "already know haskell but not know objc" step is implied.
he just wants to show he's got a big e-penis.

well, then, let's grab some "reliable sources" on our "considered harmful, unscientific and ultimately destructive non-notable programming languages".

i'll go for racket, d and clojure (ugh), he's clearly an ignorant moron and will not know about plt scheme's renaming. i don't know how to "save" d, though.
&gt; after all, one should ignore all rules when it helps improve things. 

that seems reasonable, why didn't anyone link that to him?
&gt; no, actually, "real" computers and the tools on them are advanced enough that these issues just don't come into play very often; it's the "wannabe" platforms (often those that pretend to be "state of the art") that cause so much trouble. obviously you've never worked with one of the better platforms or else your attitude would be quite different.

i'm impressed by your ability to radiate an aura of elitism without actually divulging any relevant information.
"notable" is, if you read the guidelines for it, meant to be a stand-in for "reliable third-party sources exist which can be cited on this topic".

unfortunately, "notable" *as actually practiced on wikipedia* does not in any way resemble this -- more often it's a stand-in for "i don't like this topic" or, more insidiously, "i want to increase my edit count".
that's a pretty neat bit of trivia:)

as a big fan of goldeneye i'd love to read the article you got it from.  do you have the source?
what about hurd? it does have some fans, but is it *notable*? i know that the creator of hurd is richard stallman, which also made the gnu os and toolchain, but i wouldn't include it in an encyclopedia until it's something that is solid, stable, mature or, *at least*, complete.

i don't want to turn this into a flamewar about what is notable or not. it probably does no harm to have hurd as an article, but it *is* true that wikipedia is being prolifered with all sorts of niche oses/kernels and things that have no relevance to an encyclopedia.

my way to say my opinion on this.
you could probably build a whole wikipedia-like site on just programming languages alone.

do that, and take it out of the hands of those philistines*.

tldr: start your own online encyclopedia if it's that important to you.



*note: i use philistines half-sarcastically there.
at first as was like wtf is this mess, then i was like *facepalm*
i believe it has more, but i could be wrong.
he's also not a crazy.
pokemon is cited everywhere*!* **who** doesn't know about pokeymans*‽‽‽*
it's the first "milhouse is not a meme" meme.
that would work, but ultimately the algorithm is much more expensive than with cuboids (though the linear scaling is a plus).

obviously you'd want to maximise the volume for the inner query to minimise the amount of filtering that would need to be done. i'm guessing that the sides of the inner cuboid would be perportional to the sides of the outer cuboid in the optimal case, so it probably wouldn't be too difficult to optimise the algorithm.
you write like 4 compilers in sicp, an introductory book to computer science.

i wouldn't say they're notoriously hard, especially for those who use the right language for the right job.

to further my point, i was helping someone learn scheme, and they knew not one thing about the language. after about an hour or two, while i was guiding him somewhat with the language constructs, he had written a compiler to compile his own little language to c. you can see it here.

https://bitbucket.org/tarballs_are_good/jeylang/src
i can only say that you are a bad programmer then. that wasn't perls fault, it was yours.
&gt; it is true that wikipedia is being proliferated with all sorts of niche languages and things that have no real relevance to an encyclopedia.

i agree. i have no problem with removing pet projects from wikipedia.

ioke is borderline. however, factor and nemerle are hardly pet projects. joy has influenced at least half a dozen languages. wikipedia is objectively less valuable without these articles.

notability of articles should be a means to an end, not an end in itself. i cannot come up with any rational justification for wanting to remove things like nemerle.
no kidding. and his claim to fame is a pokemon-strategy website.

pokemon.

edit: [no lie!](http://monsan.to/) it's the smogon link.
there is no perl. there never really was. it is perl for the language (always has been) and perl for the interpreter.
just want to point out that catalyst's entry on it's *own* wiki about why catalyst is awesome [is blank](http://wiki.catalystframework.org/wiki/why_catalyst_is_an_excellent_web_application_framework.edit).
exactly; they could have, but didn't
    module fizzbuzz;
    void main() for int i &lt;- 1..101
      (delegate string(string s) { if !s.length return "$i"; return s; }
      (["fizz", ""][eval i%3] ~ ["buzz", ""][eval i%5])
      ).writeln();

_soft mad cackling_
sorry, i don't see how keeping pages for a bunch of languages no one has heard of is improving things.
i wonder if there's a game which actively encourages this kind of technique mining... rocket jumping, pipebomb jumping etc in original team fortress comes to mind. 

it made the game feel more ... sporty
#1 is security.  almost everyone seems to fuck this up.  don't fuck this up.  especially don't seriously fuck this up and embarass yourself and put your users in danger   (e.g. reddit storing user passwords in plain text.  not hashed/salted.  not even naively encrypted.  plain.  text.  never forget.)
the long tail of knowledge
&gt; the node.js article was also deleted right away and there was no backup on deletionpedia available.

well, node isn't notable, and neither is common lisp (it's just zetalisp + interlisp!), scheme (it's just an implementation of hewit's actors atop lisp!), c (it's just bcpl with differing syntax!), pascal (it's just algol w!), algol 68 (it's just crap left over from algol h, x, &amp; y!), &amp;c &amp;c. 

i find these "notability" arguments about computer science &amp; math somewhat infuriating; i'm not a domain expert in every niche of cs, how can i determine what's notable? for that matter, i'm not a domain expert in japanese game composers, but i could see where it might be useful (say if you're working in the domain of music history &amp; want to discus change over time or difference in composition based on company, region, game genre, composer influences, &amp;c.!). i love how academic papers &amp; "third tier" text books aren't guides either, but in some areas, what else are you going to find?
what's funny is that this *particular* deletionist actually runs a site dedicated to pokemon (as a "university" no less).
incredibly well, as long as it's not given to a bunch of half-trained corporate code monkeys. it's one of a very few languages that will let you model a problem in whatever way is suited to the problem, and then get the hell out of the way while you get work done, rather than railroading you into one paradigm or another, and creating constant friction in the form of translating between a model that actually makes sense and a model that the language will permit you to use.
there are. unfortunately, i've got no one to complain to. i could try praying to god but he tends to ignore me.
britannica has an economic bound on its entries set by the cost of printing and distributing dead-tree articles.

wikipedia does not.

the marginal cost of storage for these articles is miniscule. right now i can buy hdds with a per/gb cost of ~$0.10. we're talking about a few hundred kilobytes in the worst possible case -- $0.0001 per entry.
i was talking about the runtime overhead of pthread_cancel.

sure, if you only care about static linking, most of the functions in those categories above won't matter.  but who cares about static linking in 2011?  those functions do matter in the dynamic linking case...
i suppose my opinion could be elaborated or expanded. i think gnu hurd has it's place in an encyclopedia because it is a part of the history of the gnu project, and explains the effort that was undertaken to have a gnu kernel.
it's *always* the programmer's fault, that's a truism.

however, some tools make it trivially easy to shoot yourself in the foot (by default), while others subtly point you in the right direction (while still providing sufficient opportunity to mess up). 
what. the. fuck.
if you're upset, get them to change the current policy to one that makes more sense to you, or participate in the discussions. going and lobbying random reddit users probably isn't the way to go if you want anything to change. they usually just ignore swarms that show up.
the cross-product would give you a vector pointing straight up or down in that case.
so by "sufficient experience" you mean "nearly no experience".
i think you're being too hard on clojure. it's persistent data structures are really nice. also, where most lisps list-centric, clojure is sequence centric. that means that you can, for example, pass a vector or a list or a set to a function that expects a sequence.
are they deleting a bunch of hobby project pages again? that's awesome. keep up the good work!
they are constantly deleting articles about pokemon stuff. that's actually an area where i agree with the deletions. people would put text dumps of every pokemon episode if you let them.
i really don't think nemerle meets wikipedia's notability guidelines.

if you want to claim that those guidelines should be overturned, that's all and good, but that's a seperate debate that should take place outside of the afd page.
those deletionists really start to piss me off. people invest work to create an article about some topic and those fuckers delete it because they think it's not "notable" enough for their glorious egos. 

wikipedias amount of articles isn't limited by space. while it's necessary for paper-based encyclopedias to limit the number or articles, this simply isn't the case for a web-site. 

if people fear that there is "information overload", the solution is simple: tag articles, remove references or put them in a "less noticable" category. but idiots like this stupid monsanto fuck aren't simply able to grasp the difference between a paper based medium and a computer based one. and because of their stupidity they kill the work of lots of people. and for what? for nothing besides their fucking egos.

maybe it's time to start a fork to bring wikipedia in the 21st century...

right, the part about third-party sources is what i was trying to get at with "rooted securely into a foundation that keeps it relevant".
gotta delete 'em all!
by the way, [monsanto](http://en.wikipedia.org/wiki/monsanto) is also the name of that evil gen food company who brought us agent orange¹.

[¹ article not linked because the images are pure horror.]
matrix for rotation. use homogeneous vectors and then you can do translation (and other magic) with matrices too.

nearly everything you do will boil down to multiplying matrices/vectors. in 3d this is the only way to make sense of it all - check out scene graphs.

projection from 3d onto the screen can also be done with matrix multiplications. at that point you realise it really does make sense to do as much as you can in vectors + matrices. 

i don't really have any good online resources for this stuff to hand (i'm sure some exists) but i am pretty sure vector calculus is _not_ the correct term for it (that's differentiation and such). many of the resources tend to get into the mathematical side rather than what is useful for geometry/graphics.
i use quite a few c99 features. msvc is garbage. c99 is 12 years old, there's no excuse to not be supporting it by now.
i actually don't really have a problem with trivial things being on wikipedia, but i do feel as if popcul things have a much easier time than technical articles. 
i'd love to see your goldeneye.
also as a multiple return values in python.
i think you are confused over the difference between an encyclopedia and an issue of "people" magazine.
yes, but a glance at the factor article shows that most of the sources are the factor documentation itself and some of the founding research. it's hard to know when to put in-development products in.
&gt; you're being too hard on clojure.

like every purist.

also,

    &gt; (sequence? (list 1 2 3))
    #t
    &gt; (sequence? (vector 1 2 3))
    #t
    &gt; (stream-first (list 1 2 3))
    1
    &gt; (stream-first (vector 1 2 3))
    1
    &gt; (stream-&gt;list (stream-map add1 (list 1 2 3)))
    '(2 3 4)
    &gt; (stream-&gt;list (stream-map add1 (vector 1 2 3)))
    '(2 3 4)

&gt;people would put text dumps of every pokemon episode if you let them.

they are allowed. a list of all naruto manga issues  is/was a *featured* list - the creme de la creme of list content.

http://en.wikipedia.org/wiki/list_of_naruto_manga_volumes
http://en.wikipedia.org/wiki/list_of_naruto_chapters_(part_i)
also, the reason to stick to radians in math isn't what the author says. rather, it's because it's the only unit of angle measurement in which the derivative of the sin function is the cos function. this is the real usefulness of rad, and calculus and anything built upon it becomes instantly incredibly harder if you don't use radians. 
mind = blown.

seriously, i think i got an aneurysm.
my pokemon website's being developed by 100 people but it doesn't have a wikipedia page. it's not about how much effort people put in it or how much important the project is, it's all about notability. have you got some reliable sources about hurd? it's all written in wikipedia's rules, if it's not *notable* it can't be there.
i, for one, welcome our new robot police overlords.

all object variables in java are in fact pointers to the object. the code already does this as-is.

http://javadude.com/articles/passbyvalue.htm
it's more that no one has taken the time to both create a math curriculum that teaches trig using practical applications and successfully lobby to change the current curriculum.

plus not a lot of people use trig for their jobs. hell, not a lot of *programmers* use it.

but your shitty generalization is fine, too.
my point was not that wikipedia shouldn't store these articles.  i very much think that they should for all the reasons you listed and then some.

my point was that implying that wikipedia is something lesser than a real encyclopedia because of controversy over articles that a real encyclopedia wouldn't even consider including is ridiculous.

wikipedia is something greater than an ordinary encyclopedia in large part because they *can* include articles like this and they do everyone a disservice by refusing to do so.  as someone else pointed out here, anything of greater relevance than a personal page should be kept.  it costs nothing and the idea of "clutter" on wikipedia is silly.  no one is thumbing through pages here.  people get to articles by searching and clicking on related links.  even if an article were irrelevant to most people, it's unlikely that the uninterested majority would ever even see it.
the worse sea of shit examples i've had to swim through for a project was with sql. i think i've permanently lost a few brain cells as a result.
well, i won't judge what's important to other people; i'm sure there's a sociologist *somewhere* cursing every wikipedia deletion of a pokemon article because he/she was working on a thesis about video game obsession or the like. i *still* don't see why deleting things outside your purview really matter; i mean, let's delete the prescheme article, because it doesn't add anything you can't find in the linked articles, and it's a niche subject at best. 
&gt;i hear the same rubbish about c and ada from java and .net developers.

that argument is very different.  there are still rather obvious areas where a low-level high-performance language is still necessary.

given python and ruby, there is no such argument (that i've heard) as to why people should continue using perl.
this applies to almost every article on wikipedia.
that's not the point. it's not a useful to have to pass in the object each time, in this case it's not even used. the function should not take the random generator as an object but it should use a static reference to it somewhere.
ah yeah, i see what you mean.
your attitude suggests that once anything exists all improvements to it are pointless.

glibc is very widely used, and saving "a little weight" (as well as making it cleaner and easier to build) would be widely appreciated.

i'm just not optimistic about musl's chances of achieving its goal.
nobody uses turing machines anymore, they are not notable.
i wonder if we could use this info to turn into a replica of you…
information is measured not just by quantity, but by quality. google has shown us this. finding what you want is valuable. this includes not finding stuff that isn't useful to an extent.

here's a parallel. if i want to find out the information about each of the weapons in dead space 2 or ratchet and clank: size matters, why isn't this on wikipedia? answer, because it's too esoteric. that doesn't mean the information shouldn't be somewhere. and it is in many places, on other sites or wikis. and a simple search will find this information for me. so there's no overriding info for it to be on wikipedia.

the same with these minor computer languages. it will be in many places, and many of them will be findable. but it doesn't have to be on wikipedia.
just wanted to say i love your edit.
yes it is.  you're talking about ioc containers and declarative dependency injection, not "dependency injection" in general.  capital letters have nothing to do with it.
renicing doesn't make it so background that nobody would notice. in particular, the disk i/o in linking is quite significant.
sorry that i misread you -- you made a subtle point which i failed to grasp.
well yeah it is basically a set of recursive arrays of things (data or other arrays). ram is presented as an array, so any data structure you put in there has to be describable in terms of an array, really.

the b+tree is implemented as an array of (index,data) tuples. when there are more items than can fit in the array, it is split into two arrays of tuples, with an array of (index,array) tuples to index the data arrays, etc.

but that's not the point. b+tree characteristics can *not* be deeply understood with a 5 minute explanation to someone who has had a week of cs101.

[piet](http://esolangs.org/wiki/piet) is another esoteric programming language, but it doesn't scream "joke" the way intercal does. there's clearly a distinction between the two. what does it matter that intercal is "the" esoteric language? reading about it is meant to make you laugh.
the gnu project is notable. there are notable sources on hurd. my point didn't have to do with the fact that a lot of effort has gone into the gnu project, but rather an explanation as to why effort has gone into it.
nor the curry-howard isomorphism, nor the church-turing theorem. there should only be a select few articles on programming languages, and a few cs topics; the rest should be left to niche journals &amp; the like!
actually, if you look at wikipedia's "no original research" policy, and it's citation requirements, the original intent aways was, and continues to be, merely to catalog information available somewhere else.

wikipedia is not what you think it is.
there are other rules too, so the 'asdfkljaslkfjdaklsjdfkl' article still wouldn't work.
modification, not removal of the notability criteria is ideal.  the ability to use other sources to establish notability would be good.  imagine if your "asdfkljaslkfjdaklsjdfkl" site was launched last week but was already getting more traffic than the #1 site of all time, but nothing had been published about it yet.  it's not notable according to wikipedia.
knowing exactly what people are talking about but pretending otherwise doesn't make you clever. 
is that really such an issue with multi-ghz processors and gobs... er gigs of ram? i thought that overhead was minimal.
i don't have anything to say about the notability of the pages in question but i have an idea.

were these pages very large? i don't know if this would fit in with the way that wikipedia does things, but maybe there should be a catchall page for languages not notable enough to warrant their own pages. you could have a paragraph or two for each one.

just a random idea.
if you change your reddit username to [condescendingasshole](http://www.reddit.com/r/programming/comments/fkp3o/trigonometry_is_cool_game_programming/c1gnwwv), you will get more up-votes for the irony of your comments.

everyone has to learn this stuff at some point, even if it is simple. no point in dogging people for it.
this might get some interest in [/r/datasets](http://www.reddit.com/r/datasets/) or possibly /r/netsec.
the fact that you can't tell the difference between an interpreter and a compiler puts you in no position to gauge the difficulty of creating either.
why is that funny? it might be funny if he personally made a page for every type of pokemon in existance on wikipedia.
also, a common breed of nerd will frequently proclaim how simple complex things are.

"what?? database troubles? pfffth, just read the source code to java, then oracle, then aix, then the c compiler, then the verilog for the powerpc chip you're running, and the problem will be obvious. in fact, it will be so trivial that you won't even have to skim over the circuit layout or review the lithography steps they used to make the transistors."

something one should be able to figure out.  if you pick a particular angle to fire, you can set up equations of motion for player and projectile, then solve for their intersection.  then just observe what conditions on the angle are needed for there to be an intersection, and choose that angle to fire at.
yes, but you will need trigonometry to compute a rotation matrix.
let's be clear, there should be only java, cobol and fortran. *true*, enterprise-grade, scalable programming languages. as programming-related arguments, *only* xml and xml-enabled technologies, to synergize interoperability and compatibility using a reusable, robust, easy and scalable, widespread, extensible, interchangeable serialized data format which enabled creation of simple, fast, high-quality, domain-specific languages to deliver a stable, tested product of quality.
excuse me, what.
[this](http://www.touchtrigonometry.org/) was posted on reddit recently, it's a nice tool to use.
you said more terms beyond array. what's a tuple.

(sarcasm, but just making a point).


yay! i had a similar set of thoughts once. eventually these lines of thought all lead to a (re)discovery of lisp. he'll make it there some day.

go lispers in the making!
the fact that this issue comes up so often indicates that the "notability" standard is broken.

of course fixing it would require some sort of arcane bureaucratic song and dance which really can't be initiated by an "outsider".

this is a common phenomenon. people within a bureaucracy tend to protect the structure and resist change at all cost. the only way to fix it is to knock it down and start over (fork), which resets the cycle.

there's a hilarious bbc show from the 80s that is all about exactly this type of behavior, "yes, minister".
grow some balls yourself and accept that people on reddit downvote without feeling the need to explain themself.
&gt; and a complete willingness to make that my problem :p

sounds like part of their attitude to me.
&gt; the gnu project is notable.

[notability is not inherited](http://en.wikipedia.org/wiki/wikipedia:inherit#notability_is_inherited)

&gt; there are notable sources on hurd.

i googled a bit and found nothing other than some links to the gnu project page and something written by them. notable sources, as wikipedia's rules state, must be completely made by third party and bla bla bla.

seriously, i can't imitate him more than this. let's stop here.
it's funny because i &amp; others are using pokemon as an example of seemingly trivial things that are on wikipedia, but when i looked through his userpage, it referenced his pokemon site. that's why it's funny, at least to me.
i fully believe the compromises demanded by the realities of staffing and printing are the only reasons brittanica doesn't contain an entry on nemerle. neither of these constraints apply to wikipedia, so i'm going to stand by the original statement.

if you'd like i could amend it to "i start to think it's an insult to *to the principles of* encyclopedias...". just to make the patently obvious fully clear.
well, *i* wouldn't delete an article about pokemon, a language spoken by 10 people, or variation #43 of some apple pie recipe.

there are people who care about that stuff and tomorrow i could be one of them. and if not, why would i search for it? it doesn't hurt one bit to have that extra stuff there.

he probably got one of his pokemon articles deleted and now he wants revenge.
i find [this article](http://en.wikipedia.org/wiki/wikipedia:errors_in_the_encyclop%c3%a6dia_britannica_that_have_been_corrected_in_wikipedia) to be a hilariously meta take on the subject. and [here](http://news.cnet.com/study-wikipedia-as-accurate-as-britannica/2100-1038_3-5997332.html) is some confirmation.
i guess we're in violent agreement? maybe not. either way, it seems our opinions here are generally the same.
the basic notion of wikipedia is flawed.  "it's an encyclopedia, but it's electronic!"  whoop-dee-freakin'-doo.

the users have thrust onto wikipedia their vision of an actual useful thing--an organized repository of the rapidly exploding amount of information in the human world.

but that's **not** what wikipedia is intended to be.  it's meant to be an encyclopedia, of the 18th-century variety.  nothing more than a self-contained, abridged non-fiction library.  if the information isn't somewhere else, preferably in some weighty tomb on the shelves of national libraries, it is not worthy of inclusion in the encyclopedia wikitanica.

stop bitching that wikipedia is what it is, as opposed to being what you want it to be.  wikipedia is not the problem.  the weenies that administer and police wikipedia are not the problem.  **the problem is your misunderstanding of what wikipedia is.**

once more people realize that, maybe someone can get around to actually making the hitchhiker's-guide-to-the-galaxy-like-thingy we all keep wanting wikipedia to be.
well if you know what an array is, then you know what an index is, and data is in terms of a data structure. from there, i think you have to assume the listener knows common english, otherwise where do you start? (ok tuple may not be common, but it's an ordered set of things, ok?)

very much so, i think.
he's trying to prevent wikipedia from having too much information. /s
well, i'm afraid i have to disagree; see, xml is *really* just a subset of sgml, which, we all no was **far** superior to xml in every conceivable way, is quite notable in being the basis of several modern standards (docbook, html &amp; xml itself), and it makes xml's notability somewhat *lacking*, given that it really *is* just an sgml system. i'm not really sure about java though; it's not really notable for anything other than being "production ready." i mean, really, there should only be a few programming languages there, they should be the primordial ancestors to every language we use today, and they should be categorized by family. maybe algol, cobol, fortran, assembler, simula 67, prolog &amp; lisp (since it was the first "functional language"). all others can be external references.
http://www.touchtrigonometry.org/
sadly, there's no real "way" to do it, like a button or site or anything. you just add **#t=1m22s** to the end of the url for 1 minute and 22 seconds.

i used to have to google it to remember what the format was, but i've got it down now.

[youtube help - deep links](http://www.google.com/support/youtube/bin/answer.py?hl=en&amp;answer=116618)
he goes through all this trouble with 256 "allegro-degrees", saying that:

&gt;to check for out-of-bound angles measured in degrees and convert them to the proper range, you will need to do something like this:  
    int angle_in_degrees;
    while (angle_in_degrees &gt;= 360) angle_in_degrees -= 360;
    while (angle_in_degrees &lt; 0) angle_in_degrees += 360;

guess he never heard of modulo
templates? (ie compile time metaprogramming) or language splits(like c/c++ or like the lisp or pascal  language  families).
&gt;wikipedia is something greater than an ordinary encyclopedia in large part because they can include articles like this and they do everyone a disservice by refusing to do so

wikipedia isn't deleting anything. (well, technically they are, but the people running wikipedia aren't going through deleting articles)
if i read tarballs_are_good's post correctly, he was discussing something which translated one language (a toy) to another (c).  this would be a compiler (which emits code) not an interpreter (which executes code).
i'm familiar with lisp (calling syntax literals "quotations" is a tip-off there), but i strongly believe that syntax matters. if i had to pick between homoiconicity or good syntax, i'd pick good syntax (like most programmers it seems), but my goal with magpie is to not have to make that choice at all. why not have both?
&gt; well, i wouldn't delete an article about pokemon, a language spoken by 10 people, or variation #43 of some apple pie recipe.

&gt; there are people who care about that stuff and tomorrow i could be one of them. and if not, why would i search for it? it doesn't hurt one bit to have that extra stuff there.

so long as it has *something* of note, i don't see the issue. i agree that personal projects shouldn't be on wikipedia until they have *some* level of adoption that makes them interesting; just like we don't necessarily need a wikipedia entry for every minor star wars character, we probably don't need an article per cms system. still, i think there should be more of an "expert run" atmosphere (although that has many problems too!); wtf do i know about ibises, turtles, languages spoken by 10 or fewer people or anything else outside my purview? 

&gt; he probably got one of his pokemon articles deleted and now he wants revenge.

he could just be a puritanical wikipedean (however it is spelt); there are fanatics &amp; zealots in every group. still, being irked over a personal project being deleted is a possible root cause.
no, you're missing my point.

it doesn't have to do with inheritance. it has to do with the *history* of the gnu kernel, prior to the use of linux. the development of the *de facto* free operating system is what makes hurd notable -- as well as the sources behind it (which includes that recent free software documentary) -- not because it has to do with gnu.
the trig actually can help understanding, and more importantly extending, this kind of simulation.
it's really easy to miss things like that here, and it seems to happen to my posts a lot.  i'm sure that it is in large part my fault.  
the "standard is broken" — well, ok, what's your alternative? it's strange to accuse them of resisting change when you haven't proposed a change.
**rawrr**, *that is not how the internet work!!*
whenever i read articles like this, i think of the south park episode where everytime the one kid comes up with an idea it's revealed that "the simpsons did it!".

so... "lisp did it!"
true.  but in practice you need a bit of the manipulation skill down cold to really do abstraction and extension in a creative sense.  as someone said: it's about being able to represent what you mean/want accurately and explicitly.  
you still need trig to create the initial rotation matrices.

you only need to do that once though (or use a library that does it), and after that matrices can handle most things.

it's always good to understand the underlying trig though. for one thing, like the article said, it's very natural to store at the least part of the base rotation using angles. a common form for things like player characters is using hpr (heading, pitch, and roll) angles to store rotation.

there are other useful techniques. quaternions are indispensable for blending or averaging two or more rotations together. there's really no way to cleanly average two rotation matrices and get a valid resulting rotation matrices, but quaternions handle the task perfectly. both quaternions and euler angles (a generalized form of the more specific hpr angles) are also much more efficient for transmitting rotations over a network, evan after including position.

quick graphs: [dividing by 2](http://www.wolframalpha.com/input/?i=maximum%28%7cx%7c%2c%7cy%7c%29+%2b+minimum%28%7cx%7c%2c+%7cy%7c%29+%2f+2+%3d+1) vs [dividing by 4](http://www.wolframalpha.com/input/?i=maximum\(|x|,|y|\)+%2b+minimum\(|x|,+|y|\)+/+4+=+1). i'd probably go with 1/2 as you say.
this. people don't like the result of this debate, but they sit back and pout rather than proposing an alternative notability standard.

wikipedia's a republic, not a democracy. polities are agreed to and then followed in debates, rather than deciding each debate on a case-by-case basis. it's a much more orderly and fair system.
disagree.  but i'm an ee.  trig is key to understanding radio stuff and concepts like circuit impedance in a trivial way which definitely makes it very cool.
&gt; designating the elements within a matrix requires some trig to set up, no?

a quaternion can be easily converted to a rotation matrix without using any trigonometric functions. converting an axis-angle rotation to a quaternion is one sin and cos operations. you'd only do that when you really need to specify a rotation by its angle value, if you only need to store it, you should use a quat (only 4 floats compared to a 3x3 rot matrix' 9).
ah, except you can't get to vector calculus without having trig down cold.
i was speaking of wikipedia (the software/community) not *wikimedia* (the non-profit foundation.)   
i was referring to his comment about sicp. you build several meta-circular evaluators in sicp, not compilers. in any case, i would not consider the toy project evidence that "building a compiler is easy." building a simple compiler is easy, building one that does interesting things (like lexical analysis, optimization, etc.) is hard.
my only issue with this is that, for many languages, the notability was their historicity within the general time line of computing; no one is using [small](http://en.wikipedia.org/wiki/small) anymore (actually, when i emailed the author about it some time ago, he said he didn't even have the sources around any more, and he was surprised i cared about it), but it was an interesting idea *within the time frame it was conceived*, not for any outstanding language research. does this make small notable? i've no idea; it's certainly useful when i was researching ideas for an algol-alike i was working on a few years ago, and i'm sure people in other disciplines could come up with equally interesting answers.
yeah, the line between pithy and misunderstood is a difficult one.
"i'd love to fork wikipedia &amp; take a more inclusive approach."

how would that work?

i want specifics. for example, would i be allowed to add false information? would i be allowed to delete other people's false information? would i be allowed to add pages about non-existent subjects that i've invented and present them as if they are real?

i just want a basic schematic of your fork.
of course factor is notable! i'm pretty sure most programmers have at least heard of factor.
but pokemon is a massively successful media franchise that includes many best-selling games. the user in question isn't deleting articles because he thinks they're "trivial", but because he thinks they're "non-notable". even if you think pokemon is "trivial", it's hard to deny that it's a notable subject.
are you trying to imply that the people *running* wikipedia somehow are not responsible for information being deleted according to *their own* policies? 
once you understand the abstractions, writing them in notation is simple.
my issue report: https://github.com/msporny/dna/issues#issue/6
maybe they should let kids program more, especially graphics games, and then tell them "oh, you want the car physics to look better? well, listen careful at tomorrow's trigonometry lesson..."
i would assume most programmers have *not*.

i'd even say a majority of programmers haven't heard of lisp or scheme. maybe programmers that are a part of an online community have, but many day-to-day programming-customer-databases-in-java programmers?
the problem is that establishing the notability of something on wikipedia is incredibly subjective. i've had a run in with one or two admins about these things. what gets deleted is almost entirely up to the whims of whatever admins pass by the pages. they generally ignore all the meta-fiction stuff, until something is marked for deletion. i tested this out once by merging 5 or 6 *blade runner* pages, like the separate page for deckard and the tyrell corporation, back into the main page (though the page for tannhauser gate managed to stay, go figure)

also, they make a huge stink over "it's up to *you* to establish notability". so even if something comes up with 10,000 google hits, you can't cite that as notability, you have to bring a published book or article. on the other hand, if they decide that something is notable based on some random ny post opinion page from 1981, you can forget about trying to get it deleted.
certainly, but it's also hard to judge notability as an outsider to an expert domain. unless you're only cataloging popular culture items, at some point someone with a more refined domain knowledge is going to have to look at something to determine "worth," rather than just anyone. 
i never heard of nemerle, so i thought i'd look it up on wikipedia. oh.
nothing wrong with pokemon strategy sites, but seriously, just because something is remote doesn't mean it shouldn't be documented.
thanks. new redditor here. is it ok to crosspost then?
i agree with many of your points, but not with your conclusion that they make codeigniter a horrible framework. its code is clean, it encourages php developers to at least *start* to think of their applications in a more structured way, and it provides a simple, lightweight mvc framework. ci is very procedural, but building websites is often very procedural.

i've been using it for a couple years on several different projects (some small, some large), so i'm well aware of its shortcomings. nevertheless, it has been a breath of fresh air after vanilla php, wordpress, etc.

in any case, i wasn't referring so much to codeigniter as a paragon of mvc frameworks so much as an example of cleanly-written and structured php code. its structure is easily understandable and extensible, the code is well-commented, and the documentation is clear (if sometimes lacking in technical detail).

ultimately, it's one of many available tools. if its architecture doesn't suit your purposes or taste, avoid it; if it meshes well with your programming style or development goals, it's well worth considering.
[oh shit!](http://www.youtube.com/watch?v=lp5ekmlqvi4#t=19s)
sicp, [section 5.5: compilation](http://mitpress.mit.edu/sicp/full-text/book/book-z-h-35.html#%_sec_5.5).
well, there is [this](http://en.wikipedia.org/wiki/wikipedia:ignore_all_rules) rule.
i really freaked out when i saw that! still recovering...
the problem with automated qa is that it depends on the coders, themselves writing proper and complete test cases.

to that extent, the application of deadlines being "harsh and without remorse" would only serve to weaken the likelihood of these complete test cases being written gets lower and lower as the release cycle gets faster.

and, i already hate how often the java program updates.  i'd really hate to see other programs follow suit.
&gt;far from the hardest problems in game theory though, so its a pretty easy game for a computer to win.

you make it sound like game theory is the only hard problem in computer science. 
it must be automated then... and automated qa places a lot of responsibility on the coders.  therefore, pushing up these timelines drops the effectiveness of the test cases...
[here's his contributions](http://en.wikipedia.org/w/index.php?title=special:contributions/christopher_monsanto&amp;action=view).  the best way to stop these languages from being deleted is to make convincing arguments on the afd pages of the articles in question.  i've asked him to hold on and am trying to initiate a dialog.  in the meantime, to prevent immediate damage, finding references to these languages so as to help them pass the afds would be useful.

also, ffs people cut out the personal attacks.  that's the best way to ensure these articles get deleted.  wikipedia operates according to rules, and etiquette is huge.  violating it will get you ignored and counts in favour of the other guy.

edit:  a list of the articles in question can be found [here](http://en.wikipedia.org/wiki/wikipedia:wikiproject_deletion_sorting/software).  once again, be nice, guys.  if you know something about a particular language, use that knowledge to formulate a convincing argument as to why there should be an article on it.  sources are key.
ahhh, i see. is this a widespread issue across the community? (ie deleting articles because the subject isn't "notable" enough)
well then.  i find you dumb and naive.  all of your opinions are very very wrong.  you should feel very bad about it and you should die in a very violent way.  

i, on the other hand, am always right.  i am also innocent of any bad behaviors or social mistakes that led to any misunderstandings or disagreements that occurred here or anywhere else.  i am expert in all subjects (including and especially debate) and nothing about your background or perspective could ever be worth anything from me other than derision and mockery.

and your face is stupid.
magpie is quickly becoming my favorite programming language i've never written something in.
that was the joke
lisp doesn't lack syntax due to inability, doing things like infix operators and the like is pretty trivial with just standard macros. additionally common lisp has reader macros which can actually effect very core aspects of the syntax at the reader level.

it just turns out that there is a certain beauty and consistency to the standard lisp syntax. i feel that there are stages that most lispers end up going, and they generally involve trying to add syntax to the language, before slowly realizing that the syntax has other significant advantages.
i find trigonometry useful when decomposing matrices.
sometimes you can optimize an inner loop and remove redundant matrix math.

p.s.
i don't know how many programmers don't know that a matrix can be used in pieces
right vector = 1st row. you want to shoot something rightwards? use this vector.
up vector = 2cd row.
forward vector = 3rd row. assuming 'z' is forwards, of course.
transation = 4th row


i stand corrected, although i maintain that this is still not evidence in favor of the conclusion that compliers are an "easy" subject. also, the fact that he claimed you write "like 4" compilers leads me to believe he was also referring to the meta-circular evaluators.
&gt; i want specifics. for example, would i be allowed to add false information? would i be allowed to delete other people's false information? would i be allowed to add pages about non-existent subjects that i've invented and present them as if they are real?

this works on wikipedia as it is now, no? although it's fun to play this game, it should be obvious that i'm not saying that there should be false, slanderous, &amp;c. types of information on wikipedia, but things that are backed by research, backed by domain expertise, and have *some* level of user adoption, historic weight and/or various other weights (depending on field, it might be centrality to the field itself, extension of new research, &amp;c.).

&gt; i just want a basic schematic of your fork.

most likely it would have to take place as a domain-specific encyclopedia, since i don't have the time to tend the entirety of wikipedia's breadth. i also don't think i should be given the task of judging what is notable for a (sub-)field that i have little knowledge of; there are just some areas that will be too specific for what your exact discipline is. 
i learned about nemerle from wikipedia, along with a slew of other not-widely-used languages. i've always really liked the comprehensiveness of its pl list. i agree that utterly useless stuff is worth deleting, but i'm having trouble understanding how monsanto thinks he's improving the quality of wikipedia by doing this in any way commensurate with the effort he's spending.

**cons to delete these:**

* the contributions and carefully written text of several authors is discarded.
* it becomes harder to find out about other languages.
* languages that may get more popular and were inspired by these languages now don't have the ability to link to them.
* less information on wikipedia.

**pros to deletion:**

* a list page gets a little shorter.

i'm really having trouble seeing the win here. it's not like you have to walk past these languages on the bookshelf or something. if you don't like the pages, don't click on links to them.
i feel that with lisp it's less of a "someone invented it first" and more of a "so it's been discovered before".

just as it tuns out that christopher columbus wasn't the first person to discover the americas, nor the last. it turns out that aspects of lisps are there to be discovered, not invented.

or so that's what they say about lisp.
i don't know how widespread it is.  i know that there have been similar problems in the past.  in their defense, it's bound to happen and they've always seemed very good at dealing with it.  i should probably give them the benefit of the doubt until a few days have passed.
[doesn't look like an outsider](http://monsan.to/) to the field of computer science/programming languages to me.
that's pretty much what we just said.
thanks. i can't blame you for not using it. you can't actually do anything other than print to stdout yet. but you can extend the type system!

my plan is to get around to the "make the language useful" bits after i've got all the hard core ideas figured out.
still too much java for my liking :d
they do that in a lot of cases. (tv characters, for instance) the problem is that it's even *easier* for things to be removed from there.
source code: https://github.com/qiemem/fractalviewer
&gt;also, ffs people cut out the personal attacks. that's the best way to ensure these articles get deleted. wikipedia operates according to rules, and etiquette is huge. violating it will get you ignored and counts in favour of the other guy.

seriously. it makes you wonder: are people so stupid that they don't see how counter-productive that is or do they prefer ranting to achieving their purported goal?
let me know when that happens and i'll port one of my many projects that haven't made it to the "useful" part yet either. :)
php lol
ah yes, i know of this type.
    &gt; (define car stream-first)
    &gt; (define cdr stream-rest)
    &gt; (define cons stream-cons)
    &gt; (define map stream-map)
    &gt; (define filter stream-filter)
    &gt; (define andmap stream-andmap)
    &gt; (define ormap stream-ormap)
    &gt; (define length stream-length)
    &gt; (define append stream-append)
    &gt; (define count stream-count)
    &gt; (define ref stream-ref)
    &gt; (define first stream-first)
    &gt; (define rest stream-rest)
    &gt; (car (vector 1 2 3))
    1

or,

    (module clojure-like racket/base
      (require racket/list)
      (provide
       (rename-out
        (stream-first car)
        (stream-rest cdr)
        (stream-cons cons)
        ...))) ; just define a macro called (strip-out stream- (all-defined-out racket/list)), you'll need it when defining reader macros or #langs.

&gt; cl doesn't have persistent data structures

racket does, i'm speaking of racket now.

i'm not saying clojure is not good, just that it adds nothing new to lisp, the sequences thing can be done in other lisps. scheme has guaranteed tco, lexical scopes (it still have dynamic scope), call/cc, and hygienic macros (with pattern matching, you can't imagine how much it's useful when defining macros), common lisp's got the condition system, clos and multi-dispatching, multiple namespaces (this can be both a good and bad thing), clim and the godly unwind-protect, racket can have a static, strong and safe type system that can be used from untyped and lazy code, a lazy variant that is, well, lazy and a declarative version of the language (or better, two: datalog, racklog).

did clojure learn something from them? let's see: macros are cl style: unhygienic (although they are hygienic between package boundaries, like in cl), no pattern matching (ok, maybe i'm asking too much), no optional dynamic scope (why? it's useful), multi-dispatching (yay!), single namespace (wait, with **unhygienic** macros‽), no condition system (oh well, neither does scheme), no guaranteed tco (how am i supposed to write my loops without it?), no continuations (hah! the continuation monad just does cps, doesn't it?), type *annotations* (no, they are not the same of a type system, cl has them too), java libraries (this is bad, *bad*, **bad**, i want to program in lisp with lisp libraries built on a **big** pile of lisp, with a minimal c glue code to interface with the os. you can't build sbcl without having a cl compiler and/or interpreter, the plt guys rewrote the 200k loc gui layer written in c++ in 30k loc of pure racket.)

what clojure add to lisp: uhm... uh... it removed the meaningful `car` and `cdr`, making thousands lispers rage and... uhm... perisent data stru-oh, wait, i forgot about r6rs immutable lists and racket which had them since it was still called plt scheme. uhm... let's just say "i don't know" and give clojure the benefit of the doubt, ok?

*edit* wow, this was pretty long.
it is, which is why i just went through (with my account which has a longer edit history than his, lest anyone suspect me of being some random n00b who showed up to make trouble) all his afds and voted to keep, because this sort of random deletion spree isn't constructive and never really accomplishes anything. better to give these articles some attention and see how/whether they can be improved than to just spam "delete, nn" over and over.
heh. experts... they often get mobbed away by people who don't know anything about the topic. my brother observed such a case where *the* expert of a particular voting system (the inventor himself) got so annoyed by some wikipedia contributor (who didn't even understood the math behind it) that he just left. he just couldn't be arsed to fix the damage over and over again.

being an expert doesn't mean anything. same goes for being right. the one who's more stubborn always wins.
run for the hills if they ever discover duff's device.
yep, the one you write in sicp is just the tip of the iceberg.
i know that, i'm not christopher whoeverheis.
that hurts my head
keep in mind that comp sci grew out of mathematics.  when i was in college, most the profs had been around long enough that they were actually math majors.
cs &amp; pl theory is a *huge* subject; yes, he's worked in some *very* interesting sub-areas, but i still wouldn't say he would know enough about every niche to say "yeah, that's notable!" sure, this can become problematic; the peer-review process is a nightmare. however, i still think it would help more than people who have high-level views of an area looking into sub-topics. 
what a dick. what does this douchebag write?
my most recent ridiculous query was a query that aggregated data from a dynamic number of databases in a ms sql cluster. the table names were the same in all of the dbs, so that wasn't an issue. the databases to pull from were determined by a maintenance table in one of the admin dbs.

dynamic sql gives me a headache. :(
no, debates are decided on a case by case basis, and the modal outcome is documented as 'policy'. there are no fixed rules. http://en.wikipedia.org/wiki/wikipedia:ignore_all_rules

wikipedia is most certainly not a republic. 2000 year old political systems have no place in a modern collaborative encyclopedia.

that said, the modal discussion about notability does typically end up  requiring dead trees these days. this is something that may need to be corrected at some point.
instead of /whining/ about the decisions other people make about what is placed on the website they run,  why not run your own and see how successful you are?  wikipedia is kind enough to use licensing liberal enough to get you started fast.  they'll even give you copies of articles which were previously deleted for notability reasons, though you have to ask.

personally i think this entitlement mentality is disgusting. of course you think that the particular subjects you're interested are special and notable.  but thats a pretty selfish outlook.    yes, wikipedia isn't paper.  but there are real non-trivial costs related to keeping articles around,  not the least of which is the fact that it takes considerable effort to keep them free of outright nonsense, especially when there is a shortage of regular editors with significant experience in the subject area. there also is an apparently infinite supply of spammers interested in benefiting from the "trustworthyness" (sad, but joe blow considers wikipedia pretty trustworthy) and search engine juice of wikipedia.  it might be clear you _you_ that you and your friends aren't spammers,  but that isn't clear to anyone else especially with your high and mighty entitled complaints.

and really— at the end of the day it's not healthy for the internet if wikipedia is the only source for good information on all subjects.  it's good that there are other places and things that wikipedia does not cover in infinite depth. this way, when wikipedia's policy inevitably gets something wrong we will all suffer less for it.  

so why aren't there excellent and popular alternative specialist sources for programming like there are for math (mathworld)?    perhaps because you're too busy wasting your time complaining that wikipedia won't put on their website anything that you want them to?










&gt; identical twins actually have only nearly identical dna, and differing environmental influences throughout their lives affect which genes are switched on or off. this is called epigenetic modification.

http://en.wikipedia.org/wiki/twin#genetic_and_epigenetic_similarity
too late! http://en.wikipedia.org/wiki/wikipedia:don%27t_panic

and yeah, a new h2g2 would be nice. look at wikia.com for that. ;-)
yeah, idk why you'd write the parser in java. it just seems like it'd be a nightmare. since the creator is familiar with lisp, i dunno why he didn't use clojure or something.
looks like the example was removed..
christ, what an asshole[.](http://www.robertsinclair.net/comic/asshole.html)
*[ridiculous rant filled with ad-hominems, petulant sarcasm, and no small number of mistakes along spelling, grammatical, and logical lines]*

*[trailing implication of an impossible situation involving your mother and hamsters that succinctly demonstrates a complete lack of anything approaching knowledge of the opposite sex, much less anatomy]*

*[edit to add that ***your face*** is also stupid]*
princeton phd student? who the fuck does he think he is? i am a graduate cs student at uchicago and i am reading a new programming language everyday on wiki for fun and academia.
this is too true. i spoke with an editor for a physics journal once; he was discussing how, for some time, none of the organization's papers would touch certain topics (which changed over time; condescend matter physics, physical chemistry, nano-materials, whatever), because those topics weren't theoretical enough, or weren't old enough, or no one was familiar with them. then the org would notice that they were being out published by other organizations, and *suddenly* everyone would be interested in the topic. 

it's a hard problem; you don't want overly trivial things being brought in, or "new research" or the like, but you also want to include the largest amount of digestible human knowledge, so you throw a process behind it. unfortunately, there will *always* be those who are better at the *process* than at the act of creating; and they tend to thrive in larger environments. 
[the page text (paste into a wikipedia page source and click on show preview).](http://pastebin.com/bzsjufp8)

it's actually pretty long for a deleted article, but content-wise there isn't that much outside of coding examples. 
the question is how you decide who has "a more refined domain knowledge". the dozens of editors who came from reddit to post in the afd, how many of them have "a more refined domain knowledge"? some of them didn't even register accounts. who decides that they're an expert or a non-expert? i can pretend to be a programmer who's never heard of nemerle, or i can pretend to be a programmer who uses it every day.
it's designed to delete the whole list of cars that have driven through the area.
*exactly*; someone noted that the user in question is actually [quite knowledgable](http://monsan.to/) within the realm of cs. that still doesn't mean he knows every sub-area of cs or even pl theory. it's an incredible difficult task, but the process of wikipedia's admins can make it infinitely more infuriating.
the choice of java is mostly a matter of convenience:

1. i didn't want to have to write a garbage collector.
2. i already know java (i like static oop languages).
3. it's got great tools which makes it quicker for me to iterate on things.

once the language solidifies i may end up porting it to another platform. but, overall, i don't really hate java. it's too verbose but it's not that bad.

writing a recursive descent or pratt parser really isn't that bad. i think purists would have you believe that anything but antlr or parsec is some kind of heresy, but it's just code. back when magpie's grammar was fixed, it was a couple hundred lines of pretty plain java code.
just by reading the title, isn't what lisp already does and does better?
wikipedia has guidelines such as "wikipedia is not paper" -- i.e. capacity is unlimited... but shit like this still happens.

also the underlying software is poor for maintaining this kind of thing. simple things, like:

* you can't do an equivalent of `svn blame`. have to revert to manual revision bisection. (or use external tools.)
* there's no way to make particular portions of an article protected/marked as somehow "well written". articles degrade (entropy) without a dedicated maintainer.
* there's no mechanism for verifying that a citation actually says what the user says it does.

content fork? :)
&gt; i really feel sorry for the guy who wrote them. must have taken him days to write all that stuff.

this is the problem with wikipedia. there have been occasions in the last year or two when i've spent an hour or two adding a single paragraph to wikipedia - doing the research, making sure it's well cited - and then a single dickhead can come along and ruin it in the space of two minutes. 
going by your description and the wikipedia page, i would think that small could be considered non-notable as well. there are always hundreds or thousands of these languages in development; i don't think they are notable unless they are used in some notable projects or there was significant commercial or scientific interest in them at some point.

(i'm not sure i agree with wikipedia that non-notable articles should be deleted. it seems wasteful to undo the efforts of contributors, when disk space usage doesn't seem to be an issue. i would rather see a relevancy ranking attached to articles; this might sound contrary to the idea of an encyclopedia, but wikipedia already differentiates "feature" and "good" articles from others, so i would probably prefer that articles on niche topics are labeled as such, rather than deleted.)
&gt; he probably got one of his pokemon articles deleted and now he wants revenge.

of course, anyone that disagrees with you on any trivial subject must be a scheming sociopath.
downvoted by admin at ejaz dot com ?
silly it may be, but it works. 
this is exactly my thoughts; i can't speak for every subject area, but i've read about so many odd, but historically &amp;/| academically interesting languages on wikipedia that i don't see any benefit to this sort of action. i'm also quite fond of implementing new languages, and all i see this as doing it forcing me to take my search elsewhere, and making the domain knowledge more fractured. i don't see a real benefit.
i've seen this gem done in c long before php existed.  usually used to emulate the behaviour of exception handlers.
&gt; going by your description and the wikipedia page, i would think that small could be considered non-notable as well. there are always hundreds or thousands of these languages in development; i don't think they are notable unless they are used in some notable projects or there was significant commercial or scientific interest in them at some point.

yes, that was my point; small &amp; many things like it *aren't* notable by wikipedia's guidelines, but that doesn't meant they should be discarded, simply that they should be looked at by a domain expert.

&gt; (i'm not sure i agree with wikipedia that non-notable articles should be deleted. it seems wasteful to undo the efforts of contributors, when disk space usage doesn't seem to be an issue. i would rather see a relevancy ranking attached to articles; this might sound contrary to the idea of an encyclopedia, but wikipedia already differentiates "feature" and "good" articles from others, so i would probably prefer that article son niche topics are labeled as such, rather than deleted.)

this makes it doubly painful; now one has to look elsewhere (fragmenting the search) *and* it doesn't have much of a point (save for the deletion of spam &amp; the like). 
it's of course just a theory. there could be a different motif behind his destructive sandcastle-kicking behavior.
also why a while loop? an if statement would do and remove any chance of creating an infinite loop if he accidentally put a '&lt;='  for the 0 check portion. 
that was the most beautiful sarcasm i have ever read.
ahh that makes sense.  thanks.
&gt; somebody somewhere is interested in these languages, doesn't that constitute notability?

the problem is that wikipedia doesn't have a decidable policy on notability. clearly the simple fact that someone is interested enough in a topic to create an article isn't enough to establish notability. if that were the case, then any person in the world could have a wikipedia article, as could every single musical artist and group.
that's my major complaint about java. processing text, parsing, etc. is difficult because it's so verbose.

however, for a portable language, performance is great (i'm shocked every time i see the numbers). that jit is scary good.
&gt; i have half a mind
42.
what? no [it isnt...](http://wiki.catalystframework.org/wiki/why_catalyst_is_an_excellent_web_application_framework)

also, there's other things in the world besides web frameworks..
laugh all you want, but i make good money cleaning up after idiots like this.
i suspect a lot of the issues with managing it people, technical people, scientific people, or any sort of educated, intelligent people is that they are generally straight shooters. i say this is true especially in it.

i am a software developer and i have always been a straight shooter. i don't play office politics. i don't care about internal power struggles in the company. i just want to design and develop software to be proud of with minimum interference. collaborating with peers is one thing, but having technology-illiterate management (aka phbs) get in the way infuriates me and i usually tell them why they are complete idiots. i always back up my decisions the best i can to prove it isn't simply an ego thing.

i can do the occasional dog-and-pony show and put on a good face when dealing with clients, but i have no patience for meddling micro-managers. the best manager is the one who hires the most competent people they can find and stay out of the way and run interference from outside forces.

if micro-managing is involved, then the project will go to crap. either the it staff is half-assed or the manager is trying to make himself look involved and important to the detriment of his staff. either way, micro-management is a very bad sign.
&gt;he hasn't consulted the opinions of others on this matter and thus acted alone for which there is no excuse.

this is pretty much the philosophy of wikipedia. the problem isn't what he's done, the problem is what others haven't done.
yes, i'm too late and it's frustrating ..... i want my programing wtfs!
&gt; the question is how you decide who has "a more refined domain knowledge".

well, you get subject matter experts, peer review, and votes &amp; and a hole bunch of problems. it's a messy issue, and certainly non-trivial. i've worked in physics publishing on the peer review side; that stuff get's nasty, and i'm not even taking into account my *own* experiences with getting work published. i *do* think that if you're not contributing to the article, you're not contributing to the domain that the article is in, it shouldn't really be terribly important that it be deleted (other than in the case of spam, violation of law, or other category). yes this means you'll get all sorts of absolutely low-brow trivial garbage; it also means you'll have a higher propensity for gathering &amp; fostering domain experts.

&gt; the dozens of editors who came from reddit to post in the afd, how many of them have "a more refined domain knowledge"?

i never once claimed they were correct, or that the issue is totally solved, the user in question is unfounded, &amp;c. sources were given in that reference nemerle in production contexts, but those aren't technically *notable*. my issue is with the aspect of notability, not with much else, i would guess.

&gt; some of them didn't even register accounts.

i guess that's unfortunate for a free encyclopedia that doesn't enforce you to have accounts before commenting (and some sort of pseudonymous reputation system).

&gt; who decides that they're an expert or a non-expert?

certainly not me; i don't work in .net, and i may have only a slight work area the coincides with nemerle (in types &amp; macros). from my perspective, i don't see the issue for deleting nemerle, other than wikipedia policy.

&gt; i can pretend to be a programmer who's never heard of nemerle, or i can pretend to be a programmer who uses it every day.

well, you could fix this by some sort of reputation system if you were really interested in weeding out totally trivial articles. or you could just not care if there is a community of people using a system that's not spam, not breaking the law &amp; not raising any other issues.

it's certainly not simple to fix, i'll grant you that; i simply disagree with you on the notion of *how* it should be.
i find the language articles especially valuable on wikipedia, because many notable computer science techniques are first or best implemented  in some rather obscure languages (say, dynamic deoptimization in the self language).

sadly with the deletion of these languages, the pages about the computer science techniques have to point to poorer implementations in more common languages that don't illustrate their point as well.
downloading 70kb instead of 10mb seems to benefit the end user for many reasons:

1) shorter download, less interruption for when you're gaming

2) for those in australia, less added to bandwidth caps

3) you get the update quicker.
in the dynamic linking case, what matters is whether they require initialization when they're not used. if so, that slows down program startup (think of a ./configure script that forks and execs many thousands of times) and also dirties more pages (either in .data or on the heap). musl relies entirely on static initialization - that is, the binary's .data segment loaded from disk contains the correct initial values. for example, there is no "initialize stdio" function that gets called during startup. the benefit is reduced with dynamic linking due to the necessity of relocations in some of these structures, but the library's .data is kept below 4k (1 page) which minimizes the impact.
after reviewing his writings and how he conducts himself, i firmly believe he should be stripped of all power. his behavior is unbefitting of a reasoned man, and the worst part is in all deletion cases he ignored majority consensus. not only did he motion for the deletion himself, but he also did the deletion himself.

wikipedia should implement a policy that does not allow for moderators to motion for deletion. furthermore, more than two moderators should have to weigh in to delete an article with a majority "keep" vote. at least, that way, majority opinion would matter _somewhat_.

what do you think of these ideas? perhaps a general discussion of wikipedia policy might help, too.
http://wiki.catalystframework.org/wiki/

turns out the link itself was entered incorrectly.
many other countries (like australia) does it too.
pretty sure the updater limits the speed, so your internet doesn't drop to half the speed when you update.
so? should wikipedia abolish all dates because it's not a blog? should reddit do it too?

i want to know when this documentation is made. if it's 10 years ago, things might have changed a lot.
you don't understand how the internet works.  here, you should explain that you did see his point (even tho you didn't), call his point bs, and go ad hominem to turn the discussion into a flame war.  

/s

edit:  i didn't notice [awj's post](http://www.reddit.com/r/programming/comments/fkt7t/nemerle_factor_alice_ml_and_other_programming/c1goxls) until after i made mine.

&gt; i really hate deletionists.

i can guarantee there's at least one article you'd gladly delete. it might not exist right now, but there is *something* that even you think is too moronic, too 'inside', too downright dull to merit inclusion.

so, the issue isn't whether you're a deletionist, it's where you draw the line at deleting something.
oh, man, i wish this worked with android.
[here you go](http://webcache.googleusercontent.com/search?q=cache:zgi9cxlu7vyj:php.net/manual/en/function.split.php+php.net+split&amp;cd=1&amp;hl=en&amp;ct=clnk&amp;gl=au&amp;source=www.google.com.au) (google cache)

it's the first example if you scroll down..
&gt; well, i wouldn't delete an article about pokemon, a language spoken by 10 people, or variation #43 of some apple pie recipe.

but there is something you would delete. there's something that really is that dumb. your line is just drawn in a different location from his, that's all.
how do you get a full list of the flagged pages? right now i'm just going to save a copy of the pages (yay for google cache) in case i'm ever curious and want to look them up. i usually reserve doing this for really interesting things i find on the web, but this seems like a good exception to make.

oddly enough, i remember hearing about alice ml at some point, and since i have a weird habit of bookmarking everything i find interesting, i did indeed have that wikipedia page bookmarked o_0  

what's with the sunglasses and hat and awkward hand gestures. this isn't highschool, we won't judge you for being nerdy.
but this is what stupid car industry websites are doing, lots of flashes which sometime cause problem to firefox.  honda, toyota, hyundai, ford, etc., all of their malaysia websites are full of flash bullshits.
christopher monsanto?

monsanto.
[warsow](http://en.wikipedia.org/wiki/warsow_\(video_game\))
&gt; the very competitive gameplay of warsow focuses heavily on movement and trickjumps.[3] many of the tricks in warsow, which originate from the quake series, include circle-jumping, bunny hopping, strafe-jumping, double jumping, ramp-sliding, and rocket jumping.
no, why does it matter? how does it bother you? what you just described is the mentality of an insane power mad dickhead. not normal people.
falcon..........puuuuuuuuuuuuunnnnnnnnnnch!
something about matrices just feel unsophisticated. much to my disadvantage, i checked out on learning matrices, opening for much cooler trig equations. matrices just feel 2nd grade-ish.
&gt;ordered set of things

you mean an array?
start flagging pokemon who lack notability to be deleted.
knowledgeable? 
    * website links to no code
    * only 2 upvotes for stack overflow answers

i don't care where you go to school. 
everyone has that one article. you just haven't found yours yet. here is my wikinemesis: http://en.wikipedia.org/wiki/vexel
really. the fuck, you fucking pieces of shit? be civil, you fucks.
http://news.ycombinator.com/item?id=2215346
&gt; i'd like to know where you gather that he's knowledgeable from.

to quote the person in question, "assume good faith." i'm not out to vilify him; i disagree with him. i don't think it matters really, if he is a multi-phd holder with 10 years of experience hand-coding type systems up from the ground; if he's not working in the area, not submitting new information to nemerle (or whatever sub-niche you pick) and isn't part of the community, i don't think we should take him as a real expert in notability. i agree with all the other points you make, but i think those are ancillary to my point.
you can revert it in two minutes, too.

unless you're calling wikipedia admins dickheads, since they can delete. in which case, carry on.
karmawhore
heh.
oh, i'm sure you only eat 98% cacao from beans that have been squished between the ass-cheeks of virgins, right?
i think nitwit meant episode scripts.
sorry, i must have caught you during a ninja-edit. i think you're 100% correct; there's no proof that he's knowledge able, from some sort of tangible code. i don't even really care about that; not every who is good in cs or knowledgeable about certain domain areas is going to have a large body of work to bandy about whenever we want to have proof. i think this is actually pointless; if i'm working on some sub-domain, and i have a large body of code within that sub-domain, that doesn't make me an expert about another sub-domain, unless they are closely related, and even then i may not have all the facts straight. 
